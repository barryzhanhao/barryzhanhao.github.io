<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Zhan Hao&#39;s Blogs">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Zhan Hao&#39;s Blogs">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zhan Hao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Zhan Hao's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zhan Hao's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/02/SOFAJRaft%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhan Hao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhan Hao's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/02/SOFAJRaft%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">SOFAJRaft日志存储分析（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-02 17:08:23" itemprop="dateCreated datePublished" datetime="2022-08-02T17:08:23+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-27 11:43:14" itemprop="dateModified" datetime="2024-02-27T11:43:14+08:00">2024-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">日志存储分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LogStorage分析"><a href="#LogStorage分析" class="headerlink" title="LogStorage分析"></a>LogStorage分析</h1><p>LogStorage 是日志存储实现，默认实现基于 RocksDB 存储，通过 LogStorage 接口扩展自定义日志存储实现。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.alipay.sofa.jraft.storage.LogStorage </span><br></pre></td></tr></table></figure>

<p>LogStorage 日志存储实现，核心 API 接口包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogStorage</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>&lt;<span class="title">LogStorageOptions</span>&gt;, <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="comment">//返回日志里的首/末个日志索引；</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getFirstLogIndex</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getLastLogIndex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//按照日志索引获取 Log Entry 及其任期；</span></span><br><span class="line">  <span class="function">LogEntry <span class="title">getEntry</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getTerm</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把单个/批量 Log Entry 添加到日志存储；</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">appendEntry</span><span class="params">(<span class="keyword">final</span> LogEntry entry)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">appendEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从 Log 存储头部/末尾删除日志；</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">truncatePrefix</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> firstIndexKept)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">truncateSuffix</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastIndexKept)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除所有现有日志，重置下任日志索引。</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">reset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> nextLogIndex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中LogStorage，有五个实现，Rocks的两个实现是默认实现，其余三个是jraft-extension包提供的额外实现。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034208.jpg" alt="e6c9d24egy1h4sn708bdaj218o0b6ad6"></p>
<p>而，具体使用哪种实现，是通过SPI的方式，以BDBLogStorage为例。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034221.jpg" alt="e6c9d24egy1h4sncopqjbj21xi0sijwa"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(priority = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BDBLogStorageJRaftServiceFactory</span> <span class="keyword">extends</span> <span class="title">DefaultJRaftServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LogStorage <span class="title">createLogStorage</span><span class="params">(String uri, RaftOptions raftOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BDBLogStorage(uri, raftOptions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RocksDBLogStorage"><a href="#RocksDBLogStorage" class="headerlink" title="RocksDBLogStorage"></a>RocksDBLogStorage</h1><p>RocksDBLogStorage是LogStorage的默认实现，DefaultJRaftServiceFactory返回的是RocksDBLogStorage。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJRaftServiceFactory</span> <span class="keyword">implements</span> <span class="title">JRaftServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LogStorage <span class="title">createLogStorage</span><span class="params">(<span class="keyword">final</span> String uri, <span class="keyword">final</span> RaftOptions raftOptions)</span> </span>&#123;</span><br><span class="line">    Requires.requireTrue(StringUtils.isNotBlank(uri), <span class="string">&quot;Blank log storage uri.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RocksDBLogStorage(uri, raftOptions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RocksDBLogStorage主要属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String                    path; <span class="comment">//DB存储数据路径</span></span><br><span class="line"><span class="keyword">private</span> RocksDB                         db; <span class="comment">//实际存储RocksDB</span></span><br><span class="line"><span class="keyword">private</span> ColumnFamilyHandle              defaultHandle; <span class="comment">//ColumnFamilyHandle 完成RocksDB的读写</span></span><br><span class="line"><span class="keyword">private</span> ColumnFamilyHandle              confHandle; <span class="comment">//ColumnFamily是K/V的逻辑分区</span></span><br></pre></td></tr></table></figure>

<h2 id="getEntry读取方法"><a href="#getEntry读取方法" class="headerlink" title="getEntry读取方法"></a>getEntry读取方法</h2><p>getEntry读取方法，最终是调用RocksDB的get方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LogEntry <span class="title">getEntry</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasLoadFirstLogIndex &amp;&amp; index &lt; <span class="keyword">this</span>.firstLogIndex) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getEntryFromDB(index); <span class="comment">//从DB读取</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> RocksDBException | IOException e) &#123;</span><br><span class="line">    LOG.error(<span class="string">&quot;Fail to get log entry at index &#123;&#125; in data path: &#123;&#125;.&quot;</span>, index, <span class="keyword">this</span>.path, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnlyForTest</span></span><br><span class="line"><span class="function">LogEntry <span class="title">getEntryFromDB</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span> <span class="keyword">throws</span> IOException, RocksDBException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] keyBytes = getKeyBytes(index); <span class="comment">// Key，Value都是字节流</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] bs = onDataGet(index, getValueFromRocksDB(keyBytes));</span><br><span class="line">  <span class="keyword">if</span> (bs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> LogEntry entry = <span class="keyword">this</span>.logEntryDecoder.decode(bs);</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Bad log entry format for index=&#123;&#125;, the log data is: &#123;&#125;.&quot;</span>, index, BytesUtil.toHex(bs));</span><br><span class="line">      <span class="comment">// invalid data remove? TODO</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] getValueFromRocksDB(<span class="keyword">final</span> <span class="keyword">byte</span>[] keyBytes) <span class="keyword">throws</span> RocksDBException &#123;</span><br><span class="line">  checkState();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.db.get(<span class="keyword">this</span>.defaultHandle, keyBytes); </span><br><span class="line">  <span class="comment">//调用 org.rocksdb.RocksDB#get(org.rocksdb.ColumnFamilyHandle, byte[])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="appendEntry写入方法"><a href="#appendEntry写入方法" class="headerlink" title="appendEntry写入方法"></a>appendEntry写入方法</h2><p>appendEntry写入方法，最终是调用RocksDB的put方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appendEntry</span><span class="params">(<span class="keyword">final</span> LogEntry entry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entry.getType() == EntryType.ENTRY_TYPE_CONFIGURATION) &#123;</span><br><span class="line">    <span class="keyword">return</span> executeBatch(batch -&gt; addConfBatch(entry, batch));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.db == <span class="keyword">null</span>) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;DB not initialized or destroyed in data path: &#123;&#125;.&quot;</span>, <span class="keyword">this</span>.path);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> WriteContext writeCtx = newWriteContext();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> logIndex = entry.getId().getIndex();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">byte</span>[] valueBytes = <span class="keyword">this</span>.logEntryEncoder.encode(entry);</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">byte</span>[] newValueBytes = onDataAppend(logIndex, valueBytes, writeCtx);</span><br><span class="line">      writeCtx.startJob();</span><br><span class="line">      <span class="keyword">this</span>.db.put(<span class="keyword">this</span>.defaultHandle, <span class="keyword">this</span>.writeOptions, getKeyBytes(logIndex), newValueBytes);</span><br><span class="line">      <span class="comment">//调用 org.rocksdb.RocksDB#put(org.rocksdb.ColumnFamilyHandle, org.rocksdb.WriteOptions, byte[], byte[])</span></span><br><span class="line">      writeCtx.joinAll();</span><br><span class="line">      <span class="keyword">if</span> (newValueBytes != valueBytes) &#123;</span><br><span class="line">        doSync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> RocksDBException | IOException e) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Fail to append entry.&quot;</span>, e);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RocksDB"><a href="#RocksDB" class="headerlink" title="RocksDB"></a>RocksDB</h1><p>RocksDBLogStorage底层是依托于<a target="_blank" rel="noopener" href="http://rocksdb.org/">rocksdb</a>，<a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb">github-rocksdb</a>完成存储。</p>
<blockquote>
<p>RocksDB is an <strong>embeddable</strong>  <strong>persistent</strong> <strong>key-value</strong> store for fast storage.</p>
</blockquote>
<blockquote>
<p>The RocksDB library provides a persistent key value store. <strong>Keys and values are arbitrary byte arrays</strong>. The keys are ordered within the key value store according to a user-specified comparator function.</p>
</blockquote>
<blockquote>
<p>This code is a library that forms the core building block for a fast key-value server, especially suited for storing data on flash drives. <strong>It has a Log-Structured-Merge-Database (LSM) design with flexible tradeoffs between Write-Amplification-Factor (WAF), Read-Amplification-Factor (RAF) and Space-Amplification-Factor (SAF).</strong> It has multi-threaded compactions, making it especially suitable for storing multiple terabytes of data in a single database.</p>
</blockquote>
<p>翻译一下，RocksDB 是基于 LSM-Tree 数据结构使用 C++ 编写的嵌入式 KV 存储引擎，其键值均允许使用二进制流。</p>
<p>RocksDB被广泛用于其他开源中间件。其中，Pulsar 使用 BookKeeper 作为存储层，BookKeeper 底层使用到了 RocksDB 来保存 Entry (BookKeeper 中的数据存储单元) 对应的位置索引。主流开源的 pika/kvrocks，以及云厂商的持久型 KV 存储服务，底层都是基于 RocksDB。还有大名鼎鼎的 TiDB，其存储引擎也是 RocksDB。</p>
<h1 id="LSM"><a href="#LSM" class="headerlink" title="LSM"></a>LSM</h1><h2 id="LSM定义"><a href="#LSM定义" class="headerlink" title="LSM定义"></a>LSM定义</h2><p>LSM的论文：<a target="_blank" rel="noopener" href="http://paperhub.s3.amazonaws.com/18e91eb4db2114a06ea614f0384f2784.pdf">The Log-Structured Merge-Tree (LSM Tree)</a> – O’Neil et al. ’96.</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">维基LSM定义</a>，其中，比较有意思的描述：</p>
<blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, the <strong>log-structured merge-tree</strong> (also known as <strong>LSM tree</strong>, or <strong>LSMT</strong>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-1">1]</a>) is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure">data structure</a> with performance characteristics that make it attractive for providing <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Database_index">indexed</a> access to files with high insert volume, such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transaction_log">transactional log data</a>. LSM trees, like other <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Search_tree">search trees</a>, maintain key-value pairs. LSM trees maintain data in two or more separate structures, each of which is optimized for its respective underlying storage medium; data is synchronized between the two structures efficiently, in batches.</p>
<p>One simple version of the LSM tree is a two-level LSM tree.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-2">2]</a> As described by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Patrick_O'Neil">Patrick O’Neil</a>, a two-level LSM tree comprises two <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tree_(data_structure)">tree-like</a> structures, called C0 and C1. C0 is smaller and entirely resident in memory, whereas C1 is resident on disk. New records are inserted into the memory-resident C0 component. If the insertion causes the C0 component to exceed a certain size threshold, a contiguous segment of entries is removed from C0 and merged into C1 on disk. The performance characteristics of LSM trees stem from the fact that each component is tuned to the characteristics of its underlying storage medium, and that data is efficiently migrated across media in rolling batches, using an algorithm reminiscent of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Merge_sort">merge sort</a>.</p>
<p>In order to keep down the cost of queries, the system must avoid a situation where there are too many runs.</p>
<p>LSM trees are used in data stores such as <a target="_blank" rel="noopener" href="https://asterixdb.apache.org/">Apache AsterixDB</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bigtable">Bigtable</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HBase">HBase</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/LevelDB">LevelDB</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Apache_Accumulo">Apache Accumulo</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SQLite4">SQLite4</a>,[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-6">6]</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tarantool">Tarantool</a>,[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-7">7]</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RocksDB">RocksDB</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/WiredTiger">WiredTiger</a>,[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-8">8]</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Apache_Cassandra">Apache Cassandra</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/InfluxDB">InfluxDB</a>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-9">9]</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scylla_(database)">ScyllaDB</a>.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034241.jpg" alt="e6c9d24egy1h4spclmcqdj212r0jgtaf"></p>
<p>LSM 树是一个复杂的算法设计，源自 Google 的 Bigtable 论文 （引入了术语 SSTable 和 memtable ）。基于 LSM 树算法设计实现的存储引擎，称之为 LSM 存储引擎。在 LevelDB、RocksDB、Cassandra、HBase 都基于 LSM 树算法实现了对应的存储引擎。</p>
<h2 id="LSM原理"><a href="#LSM原理" class="headerlink" title="LSM原理"></a>LSM原理</h2><h3 id="如何理解LSM？"><a href="#如何理解LSM？" class="headerlink" title="如何理解LSM？"></a>如何理解LSM？</h3><p>LSM解决的是高写负载的场景，通过顺序写入（sequential writes）优化数据写入。LSM tree持久化使用的是**Sorted Strings Table (SSTable)*<em>的数据结构。SSTables中key/value队，都是有序的，以key排序。其中key/value对，是以</em>segments*组织的。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034302.jpg" alt="e6c9d24egy1h4uj0jm861j20zu0jktbd"></p>
<h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>LSM 是顺序写入。当数据写入时，首先写入内存中的树结构（memtable），其底层数据结构通常是某种形式的排序树，如<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树</a>。写入时，数据将添加到此红黑树中。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034316.jpg" alt="e6c9d24egy1h4uj73qdyej20cq0f4dgv"></p>
<p>当内存中的红黑树达到预定义的大小，它将会一段segment按排序顺序刷到（flush）磁盘。通过数据结构的排序性，内存和硬盘两个层次，保证了顺序写入特性，即无论以任何顺序插入，最后刷新到硬盘都是有序的。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034342.jpg" alt="e6c9d24egy1h4ujcwusetj21le0q2aez"></p>
<h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>如何在SSTable中找到一个值呢？一种简单的方法是扫描扫描segments分段，即从最新的部分开始，然后回到最老的部分，直到找到要寻找的目标。但是这种简答的方法是低效的，另外的简单的优化是保持内存中的稀疏索引（sparse index）。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034353.jpg" alt="e6c9d24egy1h4ujhloeguj211y0cg0uy"></p>
<p>使用稀疏索引快速查找所需Key前后的值的偏移量。例如，查找key <code>dollar</code>。稀疏索引执行二进制搜索，key <code>dollar</code>介于 <code>dog</code> and <code>downgrade</code>之间。现在，只需要从偏移量17208扫描到19504，就可以找到该值（或确定该值缺失）。</p>
<p>稀疏索引，可以很好提高查询效率，但是如何查找不存在的记录呢？因为以上的算法，只是针对某个分段。为了确定不存在，仍然会在所有段文件上循环查找。这是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器bloom-filter</a>可以帮助解决问题。布隆过滤器是一种节省空间的数据结构，可以检查数据中是否存在值。在写入bloom过滤器时向其添加条目，并在读取开始时进行检查，以便有效地检查数据是否存在。</p>
<p>数据压缩</p>
<p>随着时间的推移，分段文件会积累。分段文件需要定期清理和维护，以防止分段文件数量失控。其过程称为压缩的过程。压缩是一个后台过程，不断地将旧分段组合到新分段的过程。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034413.jpg" alt="e6c9d24egy1h4uju3q33oj21d40oen28"></p>
<p>上图的示例中，segment1和segment2都有key <code>dog</code>的值。新分段segment4包含写入的最新值（84），即segment2的值转入segment4。很容易理解，根据时序性，新值覆盖原则。</p>
<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><p>分段文件被视为不可变（immutable），如何从SSTable中删除数据？删除数据实际上遵循与写入数据完全相同的逻辑。删除数据时，会写入一个Key/Value键值对，但是Value是称为墓碑（<strong>tombstone</strong>）的特殊标记。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034429.jpg" alt="e6c9d24egy1h4uk1pj2rkj20y00cggng"></p>
<p>如上图所示，key <code>dog</code>在segment1的有value52，segment2有墓碑标记的key。这表明，当查询key <code>dog</code>时，会返回不存在的响应。这意味着删除操作实际上会占用磁盘空间，最终，压缩后，<code>dog</code>键值对才不存在于磁盘上。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>数据写入存储在内存树（memtable）中。优化措施，还将更新其他数据结构（bloom过滤器和稀疏索引）。</p>
</li>
<li><p>当内存树（memtable）变得太大时，数据将按排序顺序刷新到磁盘。内存和硬盘使用相同的数据结构（SSTable）。</p>
</li>
<li><p>查询优化，当读取数据时，首先检查bloom过滤器。如果bloom过滤器指示不存在，直接返回不存在。如果bloom过滤器指示该值存在，则从分段文件中查找。</p>
</li>
<li><p>对片段文件，通过稀疏索引提高效率。</p>
</li>
<li><p>数据删除，是延迟删除，通过写入带有特殊标记的Key/Value键值对来实现，真正删除，是发生在压缩时。</p>
</li>
</ul>
<h1 id="RocksDB中的LSM"><a href="#RocksDB中的LSM" class="headerlink" title="RocksDB中的LSM"></a>RocksDB中的LSM</h1><p>首先引用下，官网的顶层设计架构图，图中的一些概念，和LSM的概念是吻合的。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034438.jpg" alt="e6c9d24egy1h4v59lb4gij219j0u042b"></p>
<p>接下来，简单分析下读取数据Get的源码。</p>
<p>首先rocksdb封装了SuperVersion的结构体，包含当前版本号、内存中的 MemTable 和 Immutable MemTable、SST 文件信息等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// column_family.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// holds references to memtable, all immutable memtables and version</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuperVersion</span> &#123;</span></span><br><span class="line">  <span class="comment">// Accessing members of this class is not thread-safe and requires external</span></span><br><span class="line">  <span class="comment">// synchronization (ie db mutex held or on write thread).</span></span><br><span class="line">  ColumnFamilyData* cfd;</span><br><span class="line">  MemTable* mem; <span class="comment">//内存中的 MemTable</span></span><br><span class="line">  MemTableListVersion* imm; <span class="comment">//内存中的 Immutable MemTable，是集合</span></span><br><span class="line">  Version* current; <span class="comment">//SST文件，硬盘IO</span></span><br><span class="line">  MutableCFOptions mutable_cf_options;</span><br><span class="line">  <span class="comment">// Version number of the current SuperVersion</span></span><br><span class="line">  <span class="keyword">uint64_t</span> version_number; <span class="comment">//版本号</span></span><br><span class="line">  WriteStallCondition write_stall_condition;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rocksdb 的 Get 接口 DBImpl::Get 其实现主要靠 DBImpl::GetImpl 函数调用。</p>
<p>DBImpl::GetImpl</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db_impl.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::GetImpl</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; read_options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                       GetImplOptions&amp; get_impl_options)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(get_impl_options.value != <span class="literal">nullptr</span> ||</span><br><span class="line">         get_impl_options.merge_operands != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(get_impl_options.column_family);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_options.timestamp) &#123;</span><br><span class="line">    <span class="keyword">const</span> Status s = <span class="built_in">FailIfTsMismatchCf</span>(get_impl_options.column_family,</span><br><span class="line">                                        *(read_options.timestamp),</span><br><span class="line">                                        <span class="comment">/*ts_for_read=*/</span><span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Status s = <span class="built_in">FailIfCfHasTs</span>(get_impl_options.column_family);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acquire SuperVersion</span></span><br><span class="line">  SuperVersion* sv = <span class="built_in">GetAndRefSuperVersion</span>(cfd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//略</span></span><br><span class="line">  <span class="keyword">if</span> (!skip_memtable) &#123;</span><br><span class="line">    <span class="comment">// Get value associated with key</span></span><br><span class="line">    <span class="keyword">if</span> (get_impl_options.get_value) &#123;</span><br><span class="line">      <span class="comment">// ① 从内存的MemTable读取</span></span><br><span class="line">      <span class="keyword">if</span> (sv-&gt;mem-&gt;<span class="built_in">Get</span>(lkey, get_impl_options.value-&gt;<span class="built_in">GetSelf</span>(), timestamp, &amp;s,</span><br><span class="line">                       &amp;merge_context, &amp;max_covering_tombstone_seq,</span><br><span class="line">                       read_options, get_impl_options.callback,</span><br><span class="line">                       get_impl_options.is_blob_index)) &#123;</span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        get_impl_options.value-&gt;<span class="built_in">PinSelf</span>();</span><br><span class="line">        <span class="built_in">RecordTick</span>(stats_, MEMTABLE_HIT);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((s.<span class="built_in">ok</span>() || s.<span class="built_in">IsMergeInProgress</span>()) &amp;&amp;</span><br><span class="line">                 sv-&gt;imm-&gt;<span class="built_in">Get</span>(lkey, get_impl_options.value-&gt;<span class="built_in">GetSelf</span>(),</span><br><span class="line">                              timestamp, &amp;s, &amp;merge_context,</span><br><span class="line">                              &amp;max_covering_tombstone_seq, read_options,</span><br><span class="line">                              get_impl_options.callback,</span><br><span class="line">                              get_impl_options.is_blob_index)) &#123; <span class="comment">// ② 从 内存中的 Immutable MemTable读取</span></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        get_impl_options.value-&gt;<span class="built_in">PinSelf</span>();</span><br><span class="line">        <span class="built_in">RecordTick</span>(stats_, MEMTABLE_HIT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Get Merge Operands associated with key, Merge Operands should not be</span></span><br><span class="line">      <span class="comment">// merged and raw values should be returned to the user.</span></span><br><span class="line">      <span class="keyword">if</span> (sv-&gt;mem-&gt;<span class="built_in">Get</span>(lkey, <span class="comment">/*value*/</span> <span class="literal">nullptr</span>, <span class="comment">/*timestamp=*/</span><span class="literal">nullptr</span>, &amp;s,</span><br><span class="line">                       &amp;merge_context, &amp;max_covering_tombstone_seq,</span><br><span class="line">                       read_options, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">false</span>)) &#123;  <span class="comment">// ① 从内存的MemTable读取</span></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">RecordTick</span>(stats_, MEMTABLE_HIT);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((s.<span class="built_in">ok</span>() || s.<span class="built_in">IsMergeInProgress</span>()) &amp;&amp;</span><br><span class="line">                 sv-&gt;imm-&gt;<span class="built_in">GetMergeOperands</span>(lkey, &amp;s, &amp;merge_context,</span><br><span class="line">                                           &amp;max_covering_tombstone_seq,</span><br><span class="line">                                           read_options)) &#123; <span class="comment">// ② 从 内存中的 Immutable MemTable读取</span></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">RecordTick</span>(stats_, MEMTABLE_HIT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!done &amp;&amp; !s.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">IsMergeInProgress</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReturnAndCleanupSuperVersion</span>(cfd, sv);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;DBImpl::GetImpl:PostMemTableGet:0&quot;</span>);</span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;DBImpl::GetImpl:PostMemTableGet:1&quot;</span>);</span><br><span class="line">  PinnedIteratorsManager pinned_iters_mgr;</span><br><span class="line">  <span class="keyword">if</span> (!done) &#123; <span class="comment">//均没读取数据</span></span><br><span class="line">    <span class="built_in">PERF_TIMER_GUARD</span>(get_from_output_files_time);</span><br><span class="line">    <span class="comment">// ③ 从SST文件读取</span></span><br><span class="line">    sv-&gt;current-&gt;<span class="built_in">Get</span>(</span><br><span class="line">      read_options, lkey, get_impl_options.value, timestamp, &amp;s,</span><br><span class="line">      &amp;merge_context, &amp;max_covering_tombstone_seq, &amp;pinned_iters_mgr,</span><br><span class="line">      get_impl_options.get_value ? get_impl_options.value_found : <span class="literal">nullptr</span>,</span><br><span class="line">      <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">      get_impl_options.get_value ? get_impl_options.callback : <span class="literal">nullptr</span>,</span><br><span class="line">      get_impl_options.get_value ? get_impl_options.is_blob_index : <span class="literal">nullptr</span>,</span><br><span class="line">      get_impl_options.get_value);</span><br><span class="line">    <span class="built_in">RecordTick</span>(stats_, MEMTABLE_MISS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取顺序：MemTable -&gt; MemTableListVersion -&gt; Version</p>
<p>MemTable::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memtable.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTable::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, std::string* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string* timestamp, Status* s,</span></span></span><br><span class="line"><span class="params"><span class="function">                   MergeContext* merge_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                   SequenceNumber* max_covering_tombstone_seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                   SequenceNumber* seq, <span class="keyword">const</span> ReadOptions&amp; read_opts,</span></span></span><br><span class="line"><span class="params"><span class="function">                   ReadCallback* callback, <span class="keyword">bool</span>* is_blob_index, <span class="keyword">bool</span> do_merge)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The sequence number is updated synchronously in version_set.h</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">    <span class="comment">// Avoiding recording stats for speed.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PERF_TIMER_GUARD</span>(get_from_memtable_time);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;FragmentedRangeTombstoneIterator&gt; <span class="title">range_del_iter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    NewRangeTombstoneIterator(read_opts,</span></span></span><br><span class="line"><span class="params"><span class="function">                              GetInternalKeySeqno(key.internal_key())))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (range_del_iter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *max_covering_tombstone_seq =</span><br><span class="line">      std::<span class="built_in">max</span>(*max_covering_tombstone_seq,</span><br><span class="line">               range_del_iter-&gt;<span class="built_in">MaxCoveringTombstoneSeqnum</span>(key.<span class="built_in">user_key</span>()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> found_final_value = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> merge_in_progress = s-&gt;<span class="built_in">IsMergeInProgress</span>();</span><br><span class="line">  <span class="keyword">bool</span> may_contain = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">size_t</span> ts_sz = <span class="built_in">GetInternalKeyComparator</span>().<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">  Slice user_key_without_ts = <span class="built_in">StripTimestampFromUserKey</span>(key.<span class="built_in">user_key</span>(), ts_sz);</span><br><span class="line">  <span class="keyword">bool</span> bloom_checked = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (bloom_filter_) &#123; <span class="comment">//布隆过滤器</span></span><br><span class="line">    <span class="comment">// when both memtable_whole_key_filtering and prefix_extractor_ are set,</span></span><br><span class="line">    <span class="comment">// only do whole key filtering for Get() to save CPU</span></span><br><span class="line">    <span class="keyword">if</span> (moptions_.memtable_whole_key_filtering) &#123;</span><br><span class="line">      may_contain = bloom_filter_-&gt;<span class="built_in">MayContain</span>(user_key_without_ts);</span><br><span class="line">      bloom_checked = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">assert</span>(prefix_extractor_);</span><br><span class="line">      <span class="keyword">if</span> (prefix_extractor_-&gt;<span class="built_in">InDomain</span>(user_key_without_ts)) &#123;</span><br><span class="line">        may_contain = bloom_filter_-&gt;<span class="built_in">MayContain</span>(</span><br><span class="line">          prefix_extractor_-&gt;<span class="built_in">Transform</span>(user_key_without_ts));</span><br><span class="line">        bloom_checked = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bloom_filter_ &amp;&amp; !may_contain) &#123;</span><br><span class="line">    <span class="comment">// iter is null if prefix bloom says the key does not exist</span></span><br><span class="line">    <span class="built_in">PERF_COUNTER_ADD</span>(bloom_memtable_miss_count, <span class="number">1</span>);</span><br><span class="line">    *seq = kMaxSequenceNumber;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bloom_checked) &#123;</span><br><span class="line">      <span class="built_in">PERF_COUNTER_ADD</span>(bloom_memtable_hit_count, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GetFromTable</span>(key, *max_covering_tombstone_seq, do_merge, callback,</span><br><span class="line">                 is_blob_index, value, timestamp, s, merge_context, seq,</span><br><span class="line">                 &amp;found_final_value, &amp;merge_in_progress); <span class="comment">//真正查找</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No change to value, since we have not yet found a Put/Delete</span></span><br><span class="line">  <span class="keyword">if</span> (!found_final_value &amp;&amp; merge_in_progress) &#123;</span><br><span class="line">    *s = Status::<span class="built_in">MergeInProgress</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PERF_COUNTER_ADD</span>(get_from_memtable_count, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> found_final_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTable::GetFromTable</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                            SequenceNumber max_covering_tombstone_seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">bool</span> do_merge, ReadCallback* callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">bool</span>* is_blob_index, std::string* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* timestamp, Status* s,</span></span></span><br><span class="line"><span class="params"><span class="function">                            MergeContext* merge_context, SequenceNumber* seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">bool</span>* found_final_value, <span class="keyword">bool</span>* merge_in_progress)</span> </span>&#123;</span><br><span class="line">  Saver saver;</span><br><span class="line">  saver.status = s;</span><br><span class="line">  saver.found_final_value = found_final_value;</span><br><span class="line">  saver.merge_in_progress = merge_in_progress;</span><br><span class="line">  saver.key = &amp;key;</span><br><span class="line">  saver.value = value;</span><br><span class="line">  saver.timestamp = timestamp;</span><br><span class="line">  saver.seq = kMaxSequenceNumber;</span><br><span class="line">  saver.mem = <span class="keyword">this</span>;</span><br><span class="line">  saver.merge_context = merge_context;</span><br><span class="line">  saver.max_covering_tombstone_seq = max_covering_tombstone_seq;</span><br><span class="line">  saver.merge_operator = moptions_.merge_operator;</span><br><span class="line">  saver.logger = moptions_.info_log;</span><br><span class="line">  saver.inplace_update_support = moptions_.inplace_update_support;</span><br><span class="line">  saver.statistics = moptions_.statistics;</span><br><span class="line">  saver.clock = clock_;</span><br><span class="line">  saver.callback_ = callback;</span><br><span class="line">  saver.is_blob_index = is_blob_index;</span><br><span class="line">  saver.do_merge = do_merge;</span><br><span class="line">  saver.allow_data_in_errors = moptions_.allow_data_in_errors;</span><br><span class="line">  table_-&gt;<span class="built_in">Get</span>(key, &amp;saver, SaveValue); <span class="comment">//查找方法</span></span><br><span class="line">  *seq = saver.seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTableRep::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; k, <span class="keyword">void</span>* callback_args,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">bool</span> (*callback_func)(<span class="keyword">void</span>* arg, <span class="keyword">const</span> <span class="keyword">char</span>* entry))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> iter = <span class="built_in">GetDynamicPrefixIterator</span>(); <span class="comment">//使用skiplist跳表查找</span></span><br><span class="line">  <span class="keyword">for</span> (iter-&gt;<span class="built_in">Seek</span>(k.<span class="built_in">internal_key</span>(), k.<span class="built_in">memtable_key</span>().<span class="built_in">data</span>());</span><br><span class="line">       iter-&gt;<span class="built_in">Valid</span>() &amp;&amp; <span class="built_in">callback_func</span>(callback_args, iter-&gt;<span class="built_in">key</span>());</span><br><span class="line">       iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skiplistrep.cc </span></span><br><span class="line"><span class="function">MemTableRep::Iterator* <span class="title">GetIterator</span><span class="params">(Arena* arena = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lookahead_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">void</span> *mem =</span><br><span class="line">      arena ? arena-&gt;<span class="built_in">AllocateAligned</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SkipListRep::LookaheadIterator))</span><br><span class="line">      : <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SkipListRep::LookaheadIterator));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">new</span></span> (mem) SkipListRep::<span class="built_in">LookaheadIterator</span>(*<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *mem =</span><br><span class="line">      arena ? arena-&gt;<span class="built_in">AllocateAligned</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SkipListRep::Iterator))</span><br><span class="line">      : <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SkipListRep::Iterator));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">new</span></span> (mem) SkipListRep::<span class="built_in">Iterator</span>(&amp;skip_list_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MemTableListVersion::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memtable_list.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Search all the memtables starting from the most recent one.</span></span><br><span class="line"><span class="comment">// Return the most recent value found, if any.</span></span><br><span class="line"><span class="comment">// Operands stores the list of merge operations to apply, so far.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTableListVersion::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, std::string* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::string* timestamp, Status* s,</span></span></span><br><span class="line"><span class="params"><span class="function">                              MergeContext* merge_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                              SequenceNumber* max_covering_tombstone_seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                              SequenceNumber* seq, <span class="keyword">const</span> ReadOptions&amp; read_opts,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ReadCallback* callback, <span class="keyword">bool</span>* is_blob_index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetFromList</span>(&amp;memlist_, key, value, timestamp, s, merge_context,</span><br><span class="line">                     max_covering_tombstone_seq, seq, read_opts, callback,</span><br><span class="line">                     is_blob_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTableListVersion::GetFromList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  std::list&lt;MemTable*&gt;* list, <span class="keyword">const</span> LookupKey&amp; key, std::string* value,</span></span></span><br><span class="line"><span class="params"><span class="function">  std::string* timestamp, Status* s, MergeContext* merge_context,</span></span></span><br><span class="line"><span class="params"><span class="function">  SequenceNumber* max_covering_tombstone_seq, SequenceNumber* seq,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> ReadOptions&amp; read_opts, ReadCallback* callback, <span class="keyword">bool</span>* is_blob_index)</span> </span>&#123;</span><br><span class="line">  *seq = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; memtable : *list) &#123;</span><br><span class="line">    SequenceNumber current_seq = kMaxSequenceNumber;</span><br><span class="line">    <span class="comment">//调用memtable的Get方法</span></span><br><span class="line">    <span class="keyword">bool</span> done = memtable-&gt;<span class="built_in">Get</span>(key, value, timestamp, s, merge_context,</span><br><span class="line">                              max_covering_tombstone_seq, &amp;current_seq,</span><br><span class="line">                              read_opts, callback, is_blob_index);</span><br><span class="line">    <span class="keyword">if</span> (*seq == kMaxSequenceNumber) &#123;</span><br><span class="line">      <span class="comment">// Store the most recent sequence number of any operation on this key.</span></span><br><span class="line">      <span class="comment">// Since we only care about the most recent change, we only need to</span></span><br><span class="line">      <span class="comment">// return the first operation found when searching memtables in</span></span><br><span class="line">      <span class="comment">// reverse-chronological order.</span></span><br><span class="line">      <span class="comment">// current_seq would be equal to kMaxSequenceNumber if the value was to be</span></span><br><span class="line">      <span class="comment">// skipped. This allows seq to be assigned again when the next value is</span></span><br><span class="line">      <span class="comment">// read.</span></span><br><span class="line">      *seq = current_seq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(*seq != kMaxSequenceNumber || s-&gt;<span class="built_in">IsNotFound</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!done &amp;&amp; !s-&gt;<span class="built_in">ok</span>() &amp;&amp; !s-&gt;<span class="built_in">IsMergeInProgress</span>() &amp;&amp; !s-&gt;<span class="built_in">IsNotFound</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MemTableListVersion 用链表的形式保存了所有 Immutable memtable 的结构，查找时，按时间序依次查找于每一个 memtable，如果任何一个 memtable 查找到结果则立即返回，即返回最新的返回值。具体 memtable 查找见上述 MemTable::Get 接口。</p>
<p>Version::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version_set.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; read_options, <span class="keyword">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="params"><span class="function">                  PinnableSlice* value, std::string* timestamp, Status* status,</span></span></span><br><span class="line"><span class="params"><span class="function">                  MergeContext* merge_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                  SequenceNumber* max_covering_tombstone_seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                  PinnedIteratorsManager* pinned_iters_mgr, <span class="keyword">bool</span>* value_found,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">bool</span>* key_exists, SequenceNumber* seq, ReadCallback* callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">bool</span>* is_blob, <span class="keyword">bool</span> do_merge)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//fd文件描述符</span></span><br><span class="line">  <span class="function">FilePicker <span class="title">fp</span><span class="params">(user_key, ikey, &amp;storage_info_.level_files_brief_,</span></span></span><br><span class="line"><span class="params"><span class="function">                storage_info_.num_non_empty_levels_,</span></span></span><br><span class="line"><span class="params"><span class="function">                &amp;storage_info_.file_indexer_, user_comparator(),</span></span></span><br><span class="line"><span class="params"><span class="function">                internal_comparator())</span></span>;</span><br><span class="line">  FdWithKeyRange* f = fp.<span class="built_in">GetNextFile</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (f != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    *status = table_cache_-&gt;<span class="built_in">Get</span>(</span><br><span class="line">      read_options, *<span class="built_in">internal_comparator</span>(), *f-&gt;file_metadata, ikey,</span><br><span class="line">      &amp;get_context, mutable_cf_options_.prefix_extractor,</span><br><span class="line">      cfd_-&gt;<span class="built_in">internal_stats</span>()-&gt;<span class="built_in">GetFileReadHist</span>(fp.<span class="built_in">GetHitFileLevel</span>()),</span><br><span class="line">      <span class="built_in">IsFilterSkipped</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(fp.<span class="built_in">GetHitFileLevel</span>()),</span><br><span class="line">                      fp.<span class="built_in">IsHitFileLastInLevel</span>()),</span><br><span class="line">      fp.<span class="built_in">GetHitFileLevel</span>(), max_file_size_for_l0_meta_pin_);</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    f = fp.<span class="built_in">GetNextFile</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>GetNextFile 函数会遍历所有的 level，然后再遍历每个 level 的所有的文件，这里会对 level 0 的文件做一个特殊处理，这是因为只有 level 0 的 SST 的 range 不是有序的，因此我们每次查找需要查找所有的文件，也就是会一个个的遍历；而在非 level 0，我们只需要按照二分查找来得到对应的文件即可，如果二分查找不存在，那么我就需要进入下一个 level 进行查找。</p>
<p>调用 TableCache::Get 遍历单个 SST 文件，如果查找到结果立即返回。</p>
<p>TableCache::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table_cache.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> InternalKeyComparator&amp; internal_comparator,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> FileMetaData&amp; file_meta, <span class="keyword">const</span> Slice&amp; k, GetContext* get_context,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">const</span> SliceTransform&gt;&amp; prefix_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">  HistogramImpl* file_read_hist, <span class="keyword">bool</span> skip_filters, <span class="keyword">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> max_file_size_for_l0_meta_pin)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; fd = file_meta.fd;</span><br><span class="line">  std::string* row_cache_entry = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> ROCKSDB_LITE</span></span><br><span class="line">  IterKey row_cache_key;</span><br><span class="line">  std::string row_cache_entry_buffer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check row cache if enabled. Since row cache does not currently store</span></span><br><span class="line">  <span class="comment">// sequence numbers, we cannot use it if we need to fetch the sequence.</span></span><br><span class="line">  <span class="keyword">if</span> (ioptions_.row_cache &amp;&amp; !get_context-&gt;<span class="built_in">NeedToReadSequence</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> user_key = <span class="built_in">ExtractUserKey</span>(k);</span><br><span class="line">    <span class="built_in">CreateRowCacheKeyPrefix</span>(options, fd, k, get_context, row_cache_key);</span><br><span class="line">    done = <span class="built_in">GetFromRowCache</span>(user_key, row_cache_key, row_cache_key.<span class="built_in">Size</span>(),</span><br><span class="line">                           get_context);</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">      row_cache_entry = &amp;row_cache_entry_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// ROCKSDB_LITE</span></span></span><br><span class="line">  Status s;</span><br><span class="line">  TableReader* t = fd.table_reader;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(s.<span class="built_in">ok</span>());</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">//先从缓存中读取</span></span><br><span class="line">      s = <span class="built_in">FindTable</span>(options, file_options_, internal_comparator, fd, &amp;handle,</span><br><span class="line">                    prefix_extractor,</span><br><span class="line">                    options.read_tier == kBlockCacheTier <span class="comment">/* no_io */</span>,</span><br><span class="line">                    <span class="literal">true</span> <span class="comment">/* record_read_stats */</span>, file_read_hist, skip_filters,</span><br><span class="line">                    level, <span class="literal">true</span> <span class="comment">/* prefetch_index_and_filter_in_cache */</span>,</span><br><span class="line">                    max_file_size_for_l0_meta_pin, file_meta.temperature);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        t = <span class="built_in">GetTableReaderFromHandle</span>(handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SequenceNumber* max_covering_tombstone_seq =</span><br><span class="line">      get_context-&gt;<span class="built_in">max_covering_tombstone_seq</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; max_covering_tombstone_seq != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        !options.ignore_range_deletions) &#123;</span><br><span class="line">      <span class="function">std::unique_ptr&lt;FragmentedRangeTombstoneIterator&gt; <span class="title">range_del_iter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        t-&gt;NewRangeTombstoneIterator(options))</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (range_del_iter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *max_covering_tombstone_seq = std::<span class="built_in">max</span>(</span><br><span class="line">          *max_covering_tombstone_seq,</span><br><span class="line">          range_del_iter-&gt;<span class="built_in">MaxCoveringTombstoneSeqnum</span>(<span class="built_in">ExtractUserKey</span>(k)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      get_context-&gt;<span class="built_in">SetReplayLog</span>(row_cache_entry);  <span class="comment">// nullptr if no cache.</span></span><br><span class="line">      s = t-&gt;<span class="built_in">Get</span>(options, k, get_context, prefix_extractor.<span class="built_in">get</span>(), skip_filters); <span class="comment">//从BlockBasedTable读取，即单个sst文件</span></span><br><span class="line">      get_context-&gt;<span class="built_in">SetReplayLog</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.read_tier == kBlockCacheTier &amp;&amp; s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">      <span class="comment">// Couldn&#x27;t find Table in cache but treat as kFound if no_io set</span></span><br><span class="line">      get_context-&gt;<span class="built_in">MarkKeyMayExist</span>();</span><br><span class="line">      s = Status::<span class="built_in">OK</span>();</span><br><span class="line">      done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> ROCKSDB_LITE</span></span><br><span class="line">  <span class="comment">// Put the replay log in row cache only if something was found.</span></span><br><span class="line">  <span class="keyword">if</span> (!done &amp;&amp; s.<span class="built_in">ok</span>() &amp;&amp; row_cache_entry &amp;&amp; !row_cache_entry-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> charge = row_cache_entry-&gt;<span class="built_in">capacity</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(std::string);</span><br><span class="line">    <span class="keyword">void</span>* row_ptr = <span class="keyword">new</span> std::<span class="built_in">string</span>(std::<span class="built_in">move</span>(*row_cache_entry));</span><br><span class="line">    <span class="comment">// If row cache is full, it&#x27;s OK to continue.</span></span><br><span class="line">    ioptions_.row_cache</span><br><span class="line">      -&gt;<span class="built_in">Insert</span>(row_cache_key.<span class="built_in">GetUserKey</span>(), row_ptr, charge,</span><br><span class="line">               &amp;DeleteEntry&lt;std::string&gt;)</span><br><span class="line">      .<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// ROCKSDB_LITE</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">ReleaseHandle</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> ReadOptions&amp; ro, <span class="keyword">const</span> FileOptions&amp; file_options,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> InternalKeyComparator&amp; internal_comparator, <span class="keyword">const</span> FileDescriptor&amp; fd,</span></span></span><br><span class="line"><span class="params"><span class="function">  Cache::Handle** handle,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">const</span> SliceTransform&gt;&amp; prefix_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">bool</span> no_io, <span class="keyword">bool</span> record_read_stats, HistogramImpl* file_read_hist,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">bool</span> skip_filters, <span class="keyword">int</span> level, <span class="keyword">bool</span> prefetch_index_and_filter_in_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> max_file_size_for_l0_meta_pin, Temperature file_temperature)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PERF_TIMER_GUARD_WITH_CLOCK</span>(find_table_nanos, ioptions_.clock);</span><br><span class="line">  <span class="keyword">uint64_t</span> number = fd.<span class="built_in">GetNumber</span>();</span><br><span class="line">  Slice key = <span class="built_in">GetSliceForFileNumber</span>(&amp;number);</span><br><span class="line">  *handle = cache_-&gt;<span class="built_in">Lookup</span>(key); <span class="comment">//从缓存中读取</span></span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;TableCache::FindTable:0&quot;</span>,</span><br><span class="line">                           <span class="keyword">const_cast</span>&lt;<span class="keyword">bool</span>*&gt;(&amp;no_io));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (no_io) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Incomplete</span>(<span class="string">&quot;Table not found in table_cache, no_io is set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MutexLock <span class="title">load_lock</span><span class="params">(loader_mutex_.get(key))</span></span>;</span><br><span class="line">    <span class="comment">// We check the cache again under loading mutex</span></span><br><span class="line">    *handle = cache_-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (*handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;TableReader&gt; table_reader;</span><br><span class="line">    <span class="comment">//真实读取，从磁盘读取</span></span><br><span class="line">    Status s = <span class="built_in">GetTableReader</span>(</span><br><span class="line">      ro, file_options, internal_comparator, fd, <span class="literal">false</span> <span class="comment">/* sequential mode */</span>,</span><br><span class="line">      record_read_stats, file_read_hist, &amp;table_reader, prefix_extractor,</span><br><span class="line">      skip_filters, level, prefetch_index_and_filter_in_cache,</span><br><span class="line">      max_file_size_for_l0_meta_pin, file_temperature);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(table_reader == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="built_in">RecordTick</span>(ioptions_.stats, NO_FILE_ERRORS);</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//插入缓存</span></span><br><span class="line">      s = cache_-&gt;<span class="built_in">Insert</span>(key, table_reader.<span class="built_in">get</span>(), <span class="number">1</span>, &amp;DeleteEntry&lt;TableReader&gt;,</span><br><span class="line">                         handle);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// Release ownership of table reader.</span></span><br><span class="line">        table_reader.<span class="built_in">release</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockBasedTable::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block_based_table_reader.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BlockBasedTable::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; read_options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                            GetContext* get_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> SliceTransform* prefix_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">bool</span> skip_filters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> may_match = <span class="built_in">FullFilterKeyMayMatch</span>(</span><br><span class="line">    filter, key, no_io, prefix_extractor, get_context, &amp;lookup_context,</span><br><span class="line">    read_options.rate_limiter_priority); <span class="comment">//数据块Index，稀疏索引查找</span></span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;BlockBasedTable::Get:AfterFilterMatch&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!may_match) &#123;</span><br><span class="line">    <span class="built_in">RecordTick</span>(rep_-&gt;ioptions.stats, BLOOM_FILTER_USEFUL);</span><br><span class="line">    <span class="built_in">PERF_COUNTER_BY_LEVEL_ADD</span>(bloom_filter_useful, <span class="number">1</span>, rep_-&gt;level); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//命中</span></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">    <span class="comment">//遍历，循环查找</span></span><br><span class="line">    <span class="keyword">for</span> (iiter-&gt;<span class="built_in">Seek</span>(key); iiter-&gt;<span class="built_in">Valid</span>() &amp;&amp; !done; iiter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">      IndexValue v = iiter-&gt;<span class="built_in">value</span>();</span><br><span class="line">      <span class="comment">//略</span></span><br><span class="line">      NewDataBlockIterator&lt;DataBlockIter&gt;(</span><br><span class="line">        read_options, v.handle, &amp;biter, BlockType::kData, get_context,</span><br><span class="line">        &amp;lookup_data_block_context, <span class="comment">/*prefetch_buffer=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">        <span class="comment">/*for_compaction=*/</span><span class="literal">false</span>, <span class="comment">/*async_read=*/</span><span class="literal">false</span>, tmp_status);</span><br><span class="line">      <span class="comment">//no_io，命中内存</span></span><br><span class="line">      <span class="keyword">if</span> (no_io &amp;&amp; biter.<span class="built_in">status</span>().<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">        <span class="comment">// couldn&#x27;t get block from block_cache</span></span><br><span class="line">        <span class="comment">// Update Saver.state to Found because we are only looking for</span></span><br><span class="line">        <span class="comment">// whether we can guarantee the key is not there when &quot;no_io&quot; is set</span></span><br><span class="line">        get_context-&gt;<span class="built_in">MarkKeyMayExist</span>();</span><br><span class="line">        s = biter.<span class="built_in">status</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!biter.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        s = biter.<span class="built_in">status</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">bool</span> may_exist = biter.<span class="built_in">SeekForGet</span>(key);</span><br><span class="line">      <span class="comment">// If user-specified timestamp is supported, we cannot end the search</span></span><br><span class="line">      <span class="comment">// just because hash index lookup indicates the key+ts does not exist.</span></span><br><span class="line">      <span class="keyword">if</span> (!may_exist &amp;&amp; ts_sz == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// HashSeek cannot find the key this block and the the iter is not</span></span><br><span class="line">        <span class="comment">// the end of the block, i.e. cannot be in the following blocks</span></span><br><span class="line">        <span class="comment">// either. In this case, the seek_key cannot be found, so we break</span></span><br><span class="line">        <span class="comment">// from the top level for-loop.</span></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Call the *saver function on each entry/block until it returns false</span></span><br><span class="line">        <span class="keyword">for</span> (; biter.<span class="built_in">Valid</span>(); biter.<span class="built_in">Next</span>()) &#123;</span><br><span class="line">          ParsedInternalKey parsed_key;</span><br><span class="line">          Status pik_status = <span class="built_in">ParseInternalKey</span>(</span><br><span class="line">            biter.<span class="built_in">key</span>(), &amp;parsed_key, <span class="literal">false</span> <span class="comment">/* log_err_key */</span>);  <span class="comment">// TODO</span></span><br><span class="line">          <span class="keyword">if</span> (!pik_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            s = pik_status;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//从硬盘的SST文件读取</span></span><br><span class="line">          <span class="keyword">if</span> (!get_context-&gt;<span class="built_in">SaveValue</span>(</span><br><span class="line">            parsed_key, biter.<span class="built_in">value</span>(), &amp;matched,</span><br><span class="line">            biter.<span class="built_in">IsValuePinned</span>() ? &amp;biter : <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (get_context-&gt;<span class="built_in">State</span>() == GetContext::GetState::kFound) &#123;</span><br><span class="line">              does_referenced_key_exist = <span class="literal">true</span>;</span><br><span class="line">              referenced_data_size = biter.<span class="built_in">key</span>().<span class="built_in">size</span>() + biter.<span class="built_in">value</span>().<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = biter.<span class="built_in">status</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>BlockBasedTable是 RocksDB中默认的 SST table的格式。 </p>
<p><strong>File format</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1: filter block]                  (see section: &quot;filter&quot; Meta Block)</span><br><span class="line">[meta block 2: index block]</span><br><span class="line">[meta block 3: compression dictionary block]  (see section: &quot;compression dictionary&quot; Meta Block)</span><br><span class="line">[meta block 4: range deletion block]          (see section: &quot;range deletion&quot; Meta Block)</span><br><span class="line">[meta block 5: stats block]                   (see section: &quot;properties&quot; Meta Block)</span><br><span class="line">...</span><br><span class="line">[meta block K: future extended block]  (we may add more meta blocks in the future)</span><br><span class="line">[metaindex block]</span><br><span class="line">[Footer]                               (fixed size; starts at file_size - sizeof(Footer))</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>Rocksdb 的Get 读取数据会不可避免的带来读放大（Read Amplification)。Rocksdb 的读操作需要从新到旧（从上到下）一层一层查找，直到找到想要的数据。这个过程可能需要不止一次 I/O。从level0 开始，潜在的可能会造成I/O，对于level1及以下的层级，最差情况每一层都定位到一个sst 文件，进行一次潜在I/O。这样会造成大量的读放大。所幸，引进了bloom filter减少了可能的读盘次数。另外，引入缓存优化措施，Rocksdb在各个阶段，实现了不同的缓存。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-034514.jpg" alt="e6c9d24egy1h4v74kceuxj20t40xzmze"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.sofastack.tech/blog/sofa-jraft-algorithm-storage-module-deep-dive/">https://www.sofastack.tech/blog/sofa-jraft-algorithm-storage-module-deep-dive/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/426053729">https://zhuanlan.zhihu.com/p/426053729</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/">https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">https://en.wikipedia.org/wiki/Log-structured_merge-tree</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/">https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/</a></p>
<p><a target="_blank" rel="noopener" href="https://yetanotherdevblog.com/lsm/">https://yetanotherdevblog.com/lsm/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.iggiewang.cn/2021/01/17/Rocksdb-Get/">https://www.iggiewang.cn/2021/01/17/Rocksdb-Get/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/28/SOFAJRaft%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhan Hao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhan Hao's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/28/SOFAJRaft%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90(%E4%B8%80)/" class="post-title-link" itemprop="url">SOFAJRaft日志存储分析（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-28 23:45:15" itemprop="dateCreated datePublished" datetime="2022-07-28T23:45:15+08:00">2022-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-27 11:38:54" itemprop="dateModified" datetime="2024-02-27T11:38:54+08:00">2024-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">日志存储分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇<a target="_blank" rel="noopener" href="https://barryzhanhao.github.io/2022/07/21/Raft%E5%8D%8F%E8%AE%AE%E5%92%8CSOFAJRaft%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">Raft协议和SOFAJRaft选举机制分析</a>，提到Raft协议是基于日志复制，而日志存储，SOFAJRaft是如何实现？其中又做了哪些优化的？</p>
<p>#日志存储在SOFAJRaft的实现</p>
<p>在<a target="_blank" rel="noopener" href="https://www.sofastack.tech/projects/sofa-jraft/engine-architecture/">官方顶层设计</a>中提到，关于日志存储，主要是LogStorage和LogManager。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-062131.jpg" alt="e6c9d24egy1h4n5kqgmhpj20y00u0jut"></p>
<blockquote>
<ol>
<li>Log 存储，记录 raft 配置变更和用户提交任务的日志，将从 Leader 复制到其他节点上。LogStorage 是存储实现， LogManager 负责对底层存储的调用，对调用做缓存、批量提交、必要的检查和优化。</li>
</ol>
</blockquote>
<h2 id="核心实现类"><a href="#核心实现类" class="headerlink" title="核心实现类"></a>核心实现类</h2><p>日志存储，核心实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.alipay.sofa.jraft.storage.LogStorage #接口，真正的底层存储</span><br><span class="line">com.alipay.sofa.jraft.storage.LogManager #接口，日志调用封装</span><br><span class="line">com.alipay.sofa.jraft.entity.LogEntry #日志封装</span><br><span class="line">com.alipay.sofa.jraft.entity.LogId #日志</span><br></pre></td></tr></table></figure>

<p>LogId包含term和index，两个属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogId</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">LogId</span>&gt;, <span class="title">Copiable</span>&lt;<span class="title">LogId</span>&gt;, <span class="title">Serializable</span>, <span class="title">Checksum</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>              index; <span class="comment">// 单调的LogIndex</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>              term; <span class="comment">// 单调的任期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LogEntry包含除了LogId基础信息以外，封装了一些Peers信息，还有就是重要的checksum校验和，保证日志的不可更改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogEntry</span> <span class="keyword">implements</span> <span class="title">Checksum</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** entry type */</span></span><br><span class="line">  <span class="keyword">private</span> EnumOutter.EntryType   type;</span><br><span class="line">  <span class="comment">/** log id with index/term */</span></span><br><span class="line">  <span class="keyword">private</span> LogId                  id         = <span class="keyword">new</span> LogId(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 基础信息LOGID</span></span><br><span class="line">  <span class="comment">/** log entry current peers */</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;PeerId&gt;           peers;</span><br><span class="line">  <span class="comment">/** log entry old peers */</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;PeerId&gt;           oldPeers;</span><br><span class="line">  <span class="comment">/** log entry current learners */</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;PeerId&gt;           learners;</span><br><span class="line">  <span class="comment">/** log entry old learners */</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;PeerId&gt;           oldLearners;</span><br><span class="line">  <span class="comment">/** entry data */</span></span><br><span class="line">  <span class="keyword">private</span> ByteBuffer             data       = EMPTY_DATA;</span><br><span class="line">  <span class="comment">/** checksum for log entry*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span>                   checksum; <span class="comment">//校验和</span></span><br><span class="line">  <span class="comment">/** true when the log has checksum **/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span>                hasChecksum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LogStorage是底层存储，主要完成日志真正的读写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogStorage</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>&lt;<span class="title">LogStorageOptions</span>&gt;, <span class="title">Storage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get logEntry by index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function">LogEntry <span class="title">getEntry</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Append entries to log.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">appendEntry</span><span class="params">(<span class="keyword">final</span> LogEntry entry)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Append entries to log, return append success number.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">appendEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LogManager 负责对底层存储的调用，对调用做缓存、批量提交、必要的检查和优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogManager</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>&lt;<span class="title">LogManagerOptions</span>&gt;, <span class="title">Describer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Append log entry vector and wait until it&#x27;s stable (NOT COMMITTED!)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entries log entries</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> done    callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">appendEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries, StableClosure done)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the log entry at index.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of log entry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the log entry with &#123;<span class="doctag">@code</span> index&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function">LogEntry <span class="title">getEntry</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LogManager分析"><a href="#LogManager分析" class="headerlink" title="LogManager分析"></a>LogManager分析</h2><blockquote>
<p>LogManager 负责对底层存储的调用，对调用做缓存、批量提交、必要的检查和优化</p>
</blockquote>
<p>LogManager，核心的属性，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogManagerImpl</span> <span class="keyword">implements</span> <span class="title">LogManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> LogStorage                                       logStorage; <span class="comment">//存储</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SegmentList&lt;LogEntry&gt;                      logsInMemory  = <span class="keyword">new</span> SegmentList&lt;&gt;(<span class="keyword">true</span>); <span class="comment">//内存缓存</span></span><br><span class="line">  <span class="keyword">private</span> Disruptor&lt;StableClosureEvent&gt;                    disruptor; <span class="comment">//无锁队列</span></span><br><span class="line">  <span class="keyword">private</span> RingBuffer&lt;StableClosureEvent&gt;                   diskQueue; <span class="comment">//无锁队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LogManager读取日志"><a href="#LogManager读取日志" class="headerlink" title="LogManager读取日志"></a>LogManager读取日志</h3><p><strong>缓存、必要校验</strong></p>
<p>读取方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LogEntry <span class="title">getEntry</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="keyword">this</span>.lastLogIndex || index &lt; <span class="keyword">this</span>.firstLogIndex) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> LogEntry entry = getEntryFromMemory(index); <span class="comment">//从内存缓存读取</span></span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> LogEntry entry = <span class="keyword">this</span>.logStorage.getEntry(index);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    reportError(RaftError.EIO.getNumber(), <span class="string">&quot;Corrupted entry at index=%d, not found&quot;</span>, index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Validate checksum</span></span><br><span class="line">  <span class="comment">// 检查日志完整性，其中checksum，是在日志写入的时候，存储了的</span></span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.raftOptions.isEnableLogEntryChecksum() &amp;&amp; entry.isCorrupted()) &#123;</span><br><span class="line">    String msg = String.format(<span class="string">&quot;Corrupted entry at index=%d, term=%d, expectedChecksum=%d, realChecksum=%d&quot;</span>,</span><br><span class="line">                               index, entry.getId().getTerm(), entry.getChecksum(), entry.checksum());</span><br><span class="line">    <span class="comment">// Report error to node and throw exception.</span></span><br><span class="line">    reportError(RaftError.EIO.getNumber(), msg);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> LogEntryCorruptedException(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>checksum是使用的crc算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">checksum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> c = checksum(<span class="keyword">this</span>.type.getNumber(), <span class="keyword">this</span>.id.checksum());</span><br><span class="line">  c = checksum(<span class="keyword">this</span>.peers, c);</span><br><span class="line">  c = checksum(<span class="keyword">this</span>.oldPeers, c);</span><br><span class="line">  c = checksum(<span class="keyword">this</span>.learners, c);</span><br><span class="line">  c = checksum(<span class="keyword">this</span>.oldLearners, c);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.data != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.data.hasRemaining()) &#123;</span><br><span class="line">    c = checksum(c, CrcUtil.crc64(<span class="keyword">this</span>.data));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，使用了SegmentList这个特殊的数据结构实现内存缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A list implementation based on segments. Only supports removing elements from start or end.</span></span><br><span class="line"><span class="comment"> * The list keep the elements in a segment list, every segment contains at most 128 elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                [segment, segment, segment ...]</span></span><br><span class="line"><span class="comment"> *             /                 |                    \</span></span><br><span class="line"><span class="comment"> *         segment             segment              segment</span></span><br><span class="line"><span class="comment"> *      [0, 1 ... 127]    [128, 129 ... 255]    [256, 257 ... 383]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> boyan(boyan@antfin.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>             SEGMENT_SHIFT = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>              SEGMENT_SIZE  = <span class="number">2</span> &lt;&lt; (SEGMENT_SHIFT - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;Segment&lt;T&gt;&gt; segments;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>                          size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cached offset in first segment.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>                          firstOffset;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>                recycleSegment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-062312.jpg" alt="e6c9d24egy1h4n5l08xj7j21bg0nedlw"></p>
<p>issues：<a target="_blank" rel="noopener" href="https://github.com/sofastack/sofa-jraft/pull/377">高频删除引起数据移动，内存碎片</a></p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/2023-07-03-062342.jpg" alt="e6c9d24egy1h4n5l6re89j210b0u078n"></p>
<h3 id="LogManager写入日志"><a href="#LogManager写入日志" class="headerlink" title="LogManager写入日志"></a>LogManager写入日志</h3><p><strong>批量、无锁化、异步</strong></p>
<p>写入方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries, <span class="keyword">final</span> StableClosure done)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span>(done != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  Requires.requireNonNull(done, <span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.hasError) &#123;</span><br><span class="line">    entries.clear();</span><br><span class="line">    ThreadPoolsFactory.runClosureInThread(<span class="keyword">this</span>.groupId, done, <span class="keyword">new</span> Status(RaftError.EIO, <span class="string">&quot;Corrupted LogStorage&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//校验日志是否冲突</span></span><br><span class="line">    <span class="keyword">if</span> (!entries.isEmpty() &amp;&amp; !checkAndResolveConflict(entries, done, <span class="keyword">this</span>.writeLock)) &#123;</span><br><span class="line">      <span class="comment">// If checkAndResolveConflict returns false, the done will be called in it.</span></span><br><span class="line">      entries.clear();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> LogEntry entry = entries.get(i);</span><br><span class="line">      <span class="comment">// Set checksum after checkAndResolveConflict</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.raftOptions.isEnableLogEntryChecksum()) &#123;</span><br><span class="line">        entry.setChecksum(entry.checksum()); <span class="comment">//写入checksum</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (entry.getType() == EntryType.ENTRY_TYPE_CONFIGURATION) &#123;</span><br><span class="line">        Configuration oldConf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="keyword">if</span> (entry.getOldPeers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          oldConf = <span class="keyword">new</span> Configuration(entry.getOldPeers(), entry.getOldLearners());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ConfigurationEntry conf = <span class="keyword">new</span> ConfigurationEntry(entry.getId(),</span><br><span class="line">                                                               <span class="keyword">new</span> Configuration(entry.getPeers(), entry.getLearners()), oldConf);</span><br><span class="line">        <span class="keyword">this</span>.configManager.add(conf);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!entries.isEmpty()) &#123;</span><br><span class="line">      done.setFirstLogIndex(entries.get(<span class="number">0</span>).getId().getIndex());</span><br><span class="line">      <span class="keyword">this</span>.logsInMemory.addAll(entries); <span class="comment">//写入缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">    done.setEntries(entries);</span><br><span class="line"></span><br><span class="line">    doUnlock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!wakeupAllWaiter(<span class="keyword">this</span>.writeLock)) &#123;</span><br><span class="line">      notifyLastLogIndexListeners(); <span class="comment">//通知钩子Listeners</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入无锁队列</span></span><br><span class="line">    <span class="comment">// publish event out of lock</span></span><br><span class="line">    <span class="keyword">this</span>.diskQueue.publishEvent((event, sequence) -&gt; &#123;</span><br><span class="line">      event.reset();</span><br><span class="line">      event.type = EventType.OTHER;</span><br><span class="line">      event.done = done;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">      <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候，写入storge？什么时候，从disruptor的diskQueue消费数据？答案是：AppendBatcher类，批量写入功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">AppendBatcher &#123;</span><br><span class="line">  List&lt;StableClosure&gt; storage; <span class="comment">//异步回到</span></span><br><span class="line">  <span class="keyword">int</span>                 cap;</span><br><span class="line">  <span class="keyword">int</span>                 size;</span><br><span class="line">  <span class="keyword">int</span>                 bufferSize;</span><br><span class="line">  List&lt;LogEntry&gt;      toAppend; <span class="comment">//批量数据</span></span><br><span class="line">  LogId               lastId;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AppendBatcher</span><span class="params">(<span class="keyword">final</span> List&lt;StableClosure&gt; storage, <span class="keyword">final</span> <span class="keyword">int</span> cap, <span class="keyword">final</span> List&lt;LogEntry&gt; toAppend,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">final</span> LogId lastId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    <span class="keyword">this</span>.cap = cap;</span><br><span class="line">    <span class="keyword">this</span>.toAppend = toAppend;</span><br><span class="line">    <span class="keyword">this</span>.lastId = lastId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">LogId <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lastId = appendToStorage(<span class="keyword">this</span>.toAppend); <span class="comment">//真正调用Storage，写入</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storage.get(i).getEntries().clear();</span><br><span class="line">        Status st = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (LogManagerImpl.<span class="keyword">this</span>.hasError) &#123;</span><br><span class="line">            st = <span class="keyword">new</span> Status(RaftError.EIO, <span class="string">&quot;Corrupted LogStorage&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st = Status.OK(); <span class="comment">//没有错误，状态OK</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.storage.get(i).run(st); <span class="comment">//run 完成异步回调</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          LOG.error(<span class="string">&quot;Fail to run closure with status: &#123;&#125;.&quot;</span>, st, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.toAppend.clear();</span><br><span class="line">      <span class="keyword">this</span>.storage.clear();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.bufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lastId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> StableClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="keyword">this</span>.cap || <span class="keyword">this</span>.bufferSize &gt;= LogManagerImpl.<span class="keyword">this</span>.raftOptions.getMaxAppendBufferSize()) &#123;</span><br><span class="line">      flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.storage.add(done);</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">this</span>.toAppend.addAll(done.getEntries());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> LogEntry entry : done.getEntries()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.bufferSize += entry.getData() != <span class="keyword">null</span> ? entry.getData().remaining() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正调用Storage，写入</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> LogId <span class="title">appendToStorage</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; toAppend)</span> </span>&#123;</span><br><span class="line">  LogId lastId = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.hasError) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = toAppend.size();</span><br><span class="line">    <span class="keyword">this</span>.nodeMetrics.recordSize(<span class="string">&quot;append-logs-count&quot;</span>, entriesCount);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> writtenSize = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> LogEntry entry = toAppend.get(i);</span><br><span class="line">        writtenSize += entry.getData() != <span class="keyword">null</span> ? entry.getData().remaining() : <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.nodeMetrics.recordSize(<span class="string">&quot;append-logs-bytes&quot;</span>, writtenSize);</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> nAppent = <span class="keyword">this</span>.logStorage.appendEntries(toAppend); <span class="comment">//写入</span></span><br><span class="line">      <span class="keyword">if</span> (nAppent != entriesCount) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;**Critical error**, fail to appendEntries, nAppent=&#123;&#125;, toAppend=&#123;&#125;&quot;</span>, nAppent,</span><br><span class="line">                  toAppend.size());</span><br><span class="line">        reportError(RaftError.EIO.getNumber(), <span class="string">&quot;Fail to append log entries&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (nAppent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        lastId = toAppend.get(nAppent - <span class="number">1</span>).getId();</span><br><span class="line">      &#125;</span><br><span class="line">      toAppend.clear();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.nodeMetrics.recordLatency(<span class="string">&quot;append-logs&quot;</span>, Utils.monotonicMs() - startMs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lastId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AppendBatcher类是disruptor的EventHandler核心逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">StableClosureEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">StableClosureEvent</span>&gt; </span>&#123;</span><br><span class="line">  LogId               lastId  = LogManagerImpl.<span class="keyword">this</span>.diskId;</span><br><span class="line">  List&lt;StableClosure&gt; storage = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">  AppendBatcher       ab      = <span class="keyword">new</span> AppendBatcher(<span class="keyword">this</span>.storage, <span class="number">256</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(),</span><br><span class="line">                                                  LogManagerImpl.<span class="keyword">this</span>.diskId); <span class="comment">//批量操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//消费disruptor的时间</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> StableClosureEvent event, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.type == EventType.SHUTDOWN) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lastId = <span class="keyword">this</span>.ab.flush();</span><br><span class="line">      setDiskId(<span class="keyword">this</span>.lastId);</span><br><span class="line">      LogManagerImpl.<span class="keyword">this</span>.shutDownLatch.countDown();</span><br><span class="line">      event.reset();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> StableClosure done = event.done;</span><br><span class="line">    <span class="keyword">final</span> EventType eventType = event.type;</span><br><span class="line"></span><br><span class="line">    event.reset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done.getEntries() != <span class="keyword">null</span> &amp;&amp; !done.getEntries().isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.ab.append(done); <span class="comment">//未触发条件，只是append追加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.lastId = <span class="keyword">this</span>.ab.flush(); <span class="comment">//AppendBatcher批量提交</span></span><br><span class="line">      <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">        <span class="keyword">case</span> LAST_LOG_ID:</span><br><span class="line">          ((LastLogIdClosure) done).setLastLogId(<span class="keyword">this</span>.lastId.copy());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TRUNCATE_PREFIX:</span><br><span class="line">          <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> TruncatePrefixClosure tpc = (TruncatePrefixClosure) done;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Truncating storage to firstIndexKept=&#123;&#125;.&quot;</span>, tpc.firstIndexKept);</span><br><span class="line">            ret = LogManagerImpl.<span class="keyword">this</span>.logStorage.truncatePrefix(tpc.firstIndexKept);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            LogManagerImpl.<span class="keyword">this</span>.nodeMetrics.recordLatency(<span class="string">&quot;truncate-log-prefix&quot;</span>, Utils.monotonicMs()</span><br><span class="line">                                                          - startMs);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TRUNCATE_SUFFIX:</span><br><span class="line">          startMs = Utils.monotonicMs();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> TruncateSuffixClosure tsc = (TruncateSuffixClosure) done;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Truncating storage to lastIndexKept=&#123;&#125;.&quot;</span>, tsc.lastIndexKept);</span><br><span class="line">            ret = LogManagerImpl.<span class="keyword">this</span>.logStorage.truncateSuffix(tsc.lastIndexKept);</span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">              <span class="keyword">this</span>.lastId.setIndex(tsc.lastIndexKept);</span><br><span class="line">              <span class="keyword">this</span>.lastId.setTerm(tsc.lastTermKept);</span><br><span class="line">              Requires.requireTrue(<span class="keyword">this</span>.lastId.getIndex() == <span class="number">0</span> || <span class="keyword">this</span>.lastId.getTerm() != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            LogManagerImpl.<span class="keyword">this</span>.nodeMetrics.recordLatency(<span class="string">&quot;truncate-log-suffix&quot;</span>, Utils.monotonicMs()</span><br><span class="line">                                                          - startMs);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RESET:</span><br><span class="line">          <span class="keyword">final</span> ResetClosure rc = (ResetClosure) done;</span><br><span class="line">          LOG.info(<span class="string">&quot;Resetting storage to nextLogIndex=&#123;&#125;.&quot;</span>, rc.nextLogIndex);</span><br><span class="line">          ret = LogManagerImpl.<span class="keyword">this</span>.logStorage.reset(rc.nextLogIndex);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        reportError(RaftError.EIO.getNumber(), <span class="string">&quot;Failed operation in LogStorage&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        done.run(Status.OK());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endOfBatch) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lastId = <span class="keyword">this</span>.ab.flush();</span><br><span class="line">      setDiskId(<span class="keyword">this</span>.lastId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StableClosure</span> <span class="keyword">implements</span> <span class="title">Closure</span> </span>&#123;</span><br><span class="line">  <span class="comment">//上下文信息</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span>           firstLogIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span> List&lt;LogEntry&gt; entries;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span>            nEntries;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StableClosure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NO-OP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFirstLogIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstLogIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstLogIndex</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> firstLogIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstLogIndex = firstLogIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;LogEntry&gt; <span class="title">getEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.entries;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.entries = entries;</span><br><span class="line">    <span class="keyword">if</span> (entries != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.nEntries = entries.size();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.nEntries = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StableClosure</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    setEntries(entries);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Closure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when task is done.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status the task status.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/21/Raft%E5%8D%8F%E8%AE%AE%E5%92%8CSOFAJRaft%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhan Hao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhan Hao's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/Raft%E5%8D%8F%E8%AE%AE%E5%92%8CSOFAJRaft%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Raft协议和SOFAJRaft选举机制分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-21 19:05:52" itemprop="dateCreated datePublished" datetime="2022-07-21T19:05:52+08:00">2022-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-27 14:18:42" itemprop="dateModified" datetime="2024-02-27T14:18:42+08:00">2024-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h1><h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><ul>
<li><strong>多个参与者</strong> 针对 <strong>某一件事</strong> 达成完全 <strong>一致</strong> ：一件事，一个结论。</li>
<li>已达成一致的结论，<strong>不可推翻</strong></li>
</ul>
<h2 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h2><ul>
<li>Paxos：被认为是分布式共识算法的根本，其他都是其变种，但是 Paxos 论文中只给出了单个提案的过程，并没有给出复制状态机中需要的 multi-paxos 的相关细节的描述，实现 Paxos 具有很高的工程复杂度（如多点可写，允许日志空洞等）。</li>
<li>Zab：被应用在 Zookeeper 中，业界使用广泛，但没有抽象成通用的 library。</li>
<li>Raft：以容易理解著称，业界也涌现出很多 Raft 实现，比如大名鼎鼎的 etcd, braft, tikv 等。</li>
</ul>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>Raft是基于日志复制的分布式一致性共识算法 (Consensus Algorithm)，<a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">论文地址:In Search of an Understandable Consensus Algorithm</a>。</p>
<p><a target="_blank" rel="noopener" href="https://raft.github.io/">Raft</a> 是一种更易于理解的分布式共识算法，核心协议本质上还是师承 Paxos 的精髓，不同的是依靠 Raft 模块化的拆分以及更加简化的设计，Raft 协议相对更容易实现。</p>
<ul>
<li><p>模块化的拆分主要体现在：Raft 把一致性协议划分为 Leader 选举、MemberShip 变更、日志复制、Snapshot 等几个几乎完全解耦的模块。</p>
</li>
<li><p>更加简化的设计则体现在：Raft 不允许类似 Paxos 中的乱序提交、简化系统中的角色状态（只有 Leader、Follower、Candidate 三种角色）、限制仅 Leader 可写入、使用随机化的超时时间来设计 Leader Election 等等。 </p>
</li>
</ul>
<h2 id="Raft节点"><a href="#Raft节点" class="headerlink" title="Raft节点"></a>Raft节点</h2><p>Raft将系统中的节点分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：</p>
<ul>
<li><strong>Leader</strong>：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li>
<li><strong>Follower</strong>：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li>
<li><strong>Candidate</strong>：Leader选举过程中的临时角色。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/5ce30991fccd0245a0ccb38e122e3ab5.jpg" alt="5ce30991fccd0245a0ccb38e122e3ab5"></p>
<h2 id="节点转换"><a href="#节点转换" class="headerlink" title="节点转换"></a>节点转换</h2><p>Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。</p>
<p>Raft算法角色状态转换如下：</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/v2-7f64a2df8f8817932ed047d35878bca9_r.jpg" alt="preview"></p>
<p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
<h2 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h2><ol>
<li>时间被划分为一个个任期 (term)，term id 按时间轴单调递增；</li>
<li>每一个任期的开始都是 Leader 选举，选举成功之后，Leader 在任期内管理整个集群，也就是 <strong>“选举 + 常规操作”</strong>；</li>
<li>每个任期最多一个 Leader，可能没有 Leader (spilt-vote 导致)。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/A*CTpYRa_CB_4AAAAAAAAAAABjARQnAQ.png" alt="本图出自《Raft: A Consensus Algorithm for Replicated Logs》"></p>
<h1 id="SOFAJRaft"><a href="#SOFAJRaft" class="headerlink" title="SOFAJRaft"></a>SOFAJRaft</h1><p><a target="_blank" rel="noopener" href="https://github.com/sofastack/sofa-jraft">SOFAJRaft</a> 是一个基于 <a target="_blank" rel="noopener" href="https://raft.github.io/">Raft</a> 一致性算法的生产级高性能 Java 实现，支持 MULTI-RAFT-GROUP，适用于高负载低延迟的场景。 使用 SOFAJRaft 你可以专注于自己的业务领域，由 SOFAJRaft 负责处理所有与 Raft 相关的技术难题，并且 SOFAJRaft 非常易于使用，你可以通过几个示例在很短的时间内掌握它。</p>
<p>SOFAJRaft 是从百度的 <a target="_blank" rel="noopener" href="https://github.com/brpc/braft">braft</a> 移植而来，做了一些优化和改进，感谢百度 braft 团队开源了如此优秀的 C++ Raft 实现。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/8f09de2681270cdc21ddcc8f4f4f5dd3.jpg" alt="8f09de2681270cdc21ddcc8f4f4f5dd3"></p>
<blockquote>
<p>整个系统围绕着Node进行。涵盖了日志管理、元数据存储、快照、状态机、日志复制等模块。Node和Node之间通过RPC进行通信。<br>系统日志模块和状态机的任务都是通过Disruptor异步去执行。</p>
</blockquote>
<ul>
<li>FSMCaller主要就是将日志同步到状态机。</li>
<li>LogManager，顾名思义，就是管理日志。</li>
<li>MetaStorage用来存储节点的元数据信息。</li>
<li>SnapshotExecutor就是快照方面的实现。</li>
</ul>
<h1 id="SOFAJRaft选举机制"><a href="#SOFAJRaft选举机制" class="headerlink" title="SOFAJRaft选举机制"></a>SOFAJRaft选举机制</h1><p>其中，SOFAJRaft 的选举中包含了对两个属性的判断：LogIndex 和 Term。</p>
<ul>
<li>Term 即任期</li>
<li>LogIndex即提交到 raft group  中的任务都将序列化为一条日志存储下来，每条日志一个编号，在整个 raft group 内单调递增并复制到每个 raft  节点。可以理解为事务id。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/v2-05b80ce9095004381b5846c6179f932e_1440w.jpg" alt="img"></p>
<p>SOFAJRaft选举机制，大致如下：</p>
<ol>
<li>Candidate 被 ET（Election Timeout） 触发</li>
<li>Candidate 开始尝试发起 pre-vote 预投票</li>
<li>Follower 判断是否认可该 pre-vote request</li>
<li>Candidate 根据 pre-vote response 来决定是否发起 RequestVoteRequest</li>
<li>Follower 判断是否认可该 RequestVoteRequest</li>
<li>Candidate 根据 response 来判断自己是否当选</li>
</ol>
<p>这个过程可用下图表示：</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/00db32bb5b7c64ccb29418fb534fcd2a.jpg" alt="00db32bb5b7c64ccb29418fb534fcd2a"></p>
<p>在代码层面，主要是由四个方法来处理这个流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.alipay.sofa.jraft.core.NodeImpl#preVote <span class="comment">//预投票</span></span><br><span class="line">com.alipay.sofa.jraft.core.NodeImpl#electSelf <span class="comment">//投票</span></span><br><span class="line">com.alipay.sofa.jraft.core.NodeImpl#handlePreVoteRequest <span class="comment">//处理预投票请求</span></span><br><span class="line">com.alipay.sofa.jraft.core.NodeImpl#handleRequestVoteRequest <span class="comment">//处理投票请求</span></span><br></pre></td></tr></table></figure>

<p>代码逻辑比较直观，所以我们用流程图来简述各个方法中的处理。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/73d1270f3ceb31a83f219a0bb4509439.jpg" alt="73d1270f3ceb31a83f219a0bb4509439"></p>
<p>图中可见，预投票请求 preVote 和投票请求 electSelf 的流程基本类似，只是有几个细节不太一样：</p>
<ol>
<li>preVote 是由超时触发；</li>
<li>preVote 在组装 Request 的时候将 term 赋值为 currTerm + 1，而 electSelf 是先将 term ++；</li>
<li>preVote 成功后，进入 electSelf，electSelf 成功后 become Leader。</li>
</ol>
<p>处理预投票和投票请求的逻辑也比较类似，同样用图来表示。</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/93567e3a4da554bf2317c7d81f371a3b.jpg" alt="93567e3a4da554bf2317c7d81f371a3b"></p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/333627653163c92f8dc1e349178127c6.jpg" alt="333627653163c92f8dc1e349178127c6"></p>
<p>上面提到的四个方法的源码:</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/668f65dae317e2d0dc3ee41548b838b6.jpg" alt="668f65dae317e2d0dc3ee41548b838b6"></p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/6370084b53e58cb2823d732daffa65e1.jpg" alt="6370084b53e58cb2823d732daffa65e1"></p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/35b81f3ff98f33f03e639507fc817c66.jpg" alt="35b81f3ff98f33f03e639507fc817c66"></p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/5275f79fdea3f5f533403444e52e7b16.jpg" alt="5275f79fdea3f5f533403444e52e7b16"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://raft.github.io/">https://raft.github.io/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/sofastack/sofa-jraft">https://github.com/sofastack/sofa-jraft</a></p>
<p><a target="_blank" rel="noopener" href="https://www.sofastack.tech/blog/sofa-jraft-production-level-algorithm-library/">https://www.sofastack.tech/blog/sofa-jraft-production-level-algorithm-library/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.sofastack.tech/blog/sofa-jraft-election-mechanism/">https://www.sofastack.tech/blog/sofa-jraft-election-mechanism/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luozhiyun/p/11743469.html">https://www.cnblogs.com/luozhiyun/p/11743469.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32052223">https://zhuanlan.zhihu.com/p/32052223</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luozhiyun/p/11743469.html">https://www.cnblogs.com/luozhiyun/p/11743469.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yunqiinsight/article/details/117515558">https://blog.csdn.net/yunqiinsight/article/details/117515558</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1688836">https://cloud.tencent.com/developer/article/1688836</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/10/Spring%20Cloud%20Contract%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhan Hao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhan Hao's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/10/Spring%20Cloud%20Contract%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">Spring Cloud Contract使用经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-10 13:58:04" itemprop="dateCreated datePublished" datetime="2021-06-10T13:58:04+08:00">2021-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-27 11:36:27" itemprop="dateModified" datetime="2024-02-27T11:36:27+08:00">2024-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="API接口，集成测试中遇到的问题"><a href="#API接口，集成测试中遇到的问题" class="headerlink" title="API接口，集成测试中遇到的问题"></a>API接口，集成测试中遇到的问题</h1><p>目前，项目中，集成测试，遇到RPC远程调用，采取的是端对端Mock API接口的方式。具体实现，是用WireMock，在Spring Boot Test上下文启动的时候，手动启动一个WireMock Server，然后在各个测试用例里面，Stub API接口。</p>
<p>遇到的问题：</p>
<ul>
<li>站在消费者的角度，编写Mock 数据，有重复的工作量。比如A -&gt; C，B -&gt; C，A、B调用了C的某个API接口，Mock API接口的时候，在A、B项目里面，就会编写相同的Stubs。</li>
<li>无法及时感知API接口的变更。比如，目前使用WireMock，来Mock API  HTTP接口，是使用的JSON格式的文件，来Mock接口返回值，如果API接口增加了一个字段，消费者很容易忽略了这个新增的字段。</li>
</ul>
<h1 id="CDC-Consumer-Driven-Contracts"><a href="#CDC-Consumer-Driven-Contracts" class="headerlink" title="CDC(Consumer-Driven Contracts)"></a>CDC(Consumer-Driven Contracts)</h1><p> Thoughtworks 的 <a target="_blank" rel="noopener" href="http://iansrobinson.com/">Ian Robinson</a> 提出的 <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/consumerDrivenContracts.html">Consumer-Driven Contracts (CDC) </a>能很好解决上述问题。</p>
<blockquote>
<p>消费者驱动的契约测试（Consumer-Driven Contracts，简称CDC），是指从消费者业务实现的角度出发，驱动出契约，再基于契约，对提供者验证的一种测试方式。</p>
</blockquote>
<h1 id="Spring-Cloud-Contract"><a href="#Spring-Cloud-Contract" class="headerlink" title="Spring Cloud Contract"></a>Spring Cloud Contract</h1><p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-contract">Spring Cloud Contract</a> 是CDC的一种具体实现。具体流程，如下图：</p>
<p><img src="https://raw.githubusercontent.com/barryzhanhao/imgs/main/730d07663fd5bf82eebbc77b2f60add3.jpg" alt="730d07663fd5bf82eebbc77b2f60add3"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-contract">https://spring.io/projects/spring-cloud-contract</a></p>
<p><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-cloud-contract">https://www.baeldung.com/spring-cloud-contract</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples">https://github.com/spring-cloud-samples/spring-cloud-contract-samples</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/03/%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%9E%84%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhan Hao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhan Hao's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/03/%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%9E%84%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">系统重构经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-03 22:00:50" itemprop="dateCreated datePublished" datetime="2021-03-03T22:00:50+08:00">2021-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-10 22:05:53" itemprop="dateModified" datetime="2021-06-10T22:05:53+08:00">2021-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8D%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">重构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>重构某个外包团队遗漏的网贷核心系统，该系统使用的框架，高度定制化，技术框架与主流的Java技术栈区别很大。比如逻辑分层处理，AS -&gt; BS -&gt; CS，其中逻辑的串联大量使用XML配置；代码质量差，存在大量重复，耦合，长代码，几千行的类，逻辑一撸到底；变量隐形传递，大量使用threadloal传递。</li>
<li>数据模型混乱，相同逻辑，重复几张相同的表；数据模型没有抽象，一张表几十个字段，一个库，上百张表。</li>
<li>使用某些停止更新的中间件和没有技术支持的闭源框架，比如mycat。</li>
</ul>
<h1 id="重构经验"><a href="#重构经验" class="headerlink" title="重构经验"></a>重构经验</h1><ul>
<li>首先，指定重构方案，方案包括分析现有状况，重构方法论，具体实施步骤，Roadmap和Deadline。</li>
<li>技术架构，采用Spring Cloud技术栈，辅助工程化和TDD思想，CI工具。</li>
<li>采用绞杀模式，新起系统，重写原有系统，逐步迁移功能。</li>
<li>文档化，在迁移功能，写代码前，先输出接口文档，流程图，时序图，数据库模型。</li>
<li>技术评审，输出文档后，需要进行技术评审，保证整理逻辑的正确性。</li>
<li>强制的代码检查和单元测试，为保证代码质量，在开发阶段，引入CheckStyle，PMD，SpotBugs代码检查。强制检查代码单元测试，使用功能Jacoco在检查代码测试覆盖度（核心逻辑要求0.9覆盖度）。</li>
<li>生产流量重放，验证模型，在完成迁移工作后，测试人员测试后，需要使用真实生产流量重放，验证接口返回值和依赖项（如DB，MQ，外部调用）的正确性，新旧接口一致；另外生产流量重放时，需要引入技术手段（如Jacoco），检查逻辑分支的覆盖度，是否覆盖大部分分支（&gt;0.8）。</li>
<li>切换接口时，接口流量，灰度切换。</li>
</ul>
<h1 id="失败点总结"><a href="#失败点总结" class="headerlink" title="失败点总结"></a>失败点总结</h1><ul>
<li>争取上级的支持，有足够的资源，不止包括开发人员，测试人员，还需要相关上下游系统的支持。很多推动性质的工作，需要有人拍板。很多重构，重写工作，不单纯的是个技术工作，更像个政治工作。</li>
<li>平衡与业务需求的冲突，大部分技术升级的工作，在老板看来是没有任何收益的。当业务需求很重的时候，如何保证重构进度和推进工作，是个难点。</li>
<li>任何技术框架，根本点还是人。团队的技术能力，决定了项目的成败。比如，如果有完善的基础设施，比如，自动化测试和沙盒环境的流量重放测试，重构或者技术升级，会变的容易的多。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/07/Java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhan Hao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhan Hao's Blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/Java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">Java单元测试和集成测试实践经验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-07 21:50:00" itemprop="dateCreated datePublished" datetime="2020-12-07T21:50:00+08:00">2020-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-27 14:21:57" itemprop="dateModified" datetime="2024-02-27T14:21:57+08:00">2024-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面的碎碎念"><a href="#写在前面的碎碎念" class="headerlink" title="写在前面的碎碎念"></a>写在前面的碎碎念</h1><ul>
<li>单元测试，集成测试，TDD（测试驱动开发）的重要性，开发和团队都在提。但却很难落地，原因无非，人的惰性和项目管理问题。</li>
<li>个人要从普通到卓越，团队要从作坊到大厂，单元测试和集成测试，TDD，是必不可少的。优秀的开源项目和大厂的核心项目，都很好实践了TDD。</li>
<li>TDD，需要转变观念：测试不是测试人员的事儿，开发需要对代码负责，写的代码是可测试的。TDD是一种更严谨的编程思想，能减轻开发维护代码的负担，为后续持续优化提供最起码的保证。单元测试和集成测试，能让开发人员在后续功能开发和重构优化更有信心，减少错误。</li>
<li>单元测试和集成测试，是软件开发最基础的保障手段。更多测试的手段有，自动化测试，流量重放和对比测试等。</li>
</ul>
<h1 id="相关书籍和文章"><a href="#相关书籍和文章" class="headerlink" title="相关书籍和文章"></a>相关书籍和文章</h1><p>##书籍</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://item.jd.com/12812626.html#crumb-wrap">《<strong>代码整洁之道</strong>》</a>，<a target="_blank" rel="noopener" href="https://item.jd.com/12584498.html#crumb-wrap">《<strong>重构 改善既有代码的设计</strong>》</a></p>
<p><em>这两本书籍是关于重构和如何写整洁的书籍。但是书中，有阐述单元测试的重要性，和如何写测试。非常值得一读。</em></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://item.jd.com/12163883.html">《<strong>Java测试驱动开发</strong>》</a></p>
<p><em>书中有很多关于TDD和Java测试框架的介绍，可以作为入门级的读物</em></p>
</li>
</ul>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/java_testing.html">Gradle 配置Test的官方介绍</a> <em>实践单元测试和集成测试，工程构建使用的Gradle</em></li>
<li><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/jacoco_plugin.html">Gradle 配置Jacoco的官方介绍</a> <em>测试用例，需要有测试覆盖度检查，才能保证测试用例真正覆盖了代码逻辑</em></li>
<li><a target="_blank" rel="noopener" href="https://phauer.com/2019/modern-best-practices-testing-java/">modern-best-practices-testing-java</a> <em>非常棒的一篇文章</em></li>
<li><a target="_blank" rel="noopener" href="https://phauer.com/2019/focus-integration-tests-mock-based-tests/">Focus on Integration Tests Instead of Mock-Based Tests</a> <em>为什么和怎么做集成测试</em></li>
<li><a target="_blank" rel="noopener" href="https://phauer.com/2017/dont-use-in-memory-databases-tests-h2/">Don’t use In-Memory Databases (H2, Fongo) for Tests</a> <em>为何放弃内存数据库作为测试依赖</em></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testing-resources">Spring Testing</a> <em>如何在Spring使用Unit Testing，Integration Testing和更多的测试学习资料</em></li>
<li><a target="_blank" rel="noopener" href="https://www.testcontainers.org/">Testcontainers</a> <em>使用容器化技术，简化测试依赖的问题，让测试更准确和高效</em></li>
<li><a target="_blank" rel="noopener" href="http://wiremock.org/">Wiremock</a> <em>强大的Mock Server</em></li>
<li><a target="_blank" rel="noopener" href="https://www.mock-server.com/">Mock-server </a><em>强大的Mock Server，同Wiremock</em></li>
</ul>
<h1 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h1><h2 id="Gradle配置Test和Jacoco"><a href="#Gradle配置Test和Jacoco" class="headerlink" title="Gradle配置Test和Jacoco"></a>Gradle配置Test和Jacoco</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">test&#123;</span><br><span class="line">  useJUnitPlatform() <span class="comment">//使用JUnit</span></span><br><span class="line">  failFast=<span class="literal">true</span>  <span class="comment">//快速失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jacocoTestReport&#123;</span><br><span class="line">  reports&#123;</span><br><span class="line">    xml.enabled <span class="literal">false</span></span><br><span class="line">    csv.enabled <span class="literal">false</span></span><br><span class="line">    html.destination file(<span class="string">&quot;$&#123;buildDir&#125;/reports.jacocoHtml&quot;</span>)  <span class="comment">//输出jacoco html文档</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jacocoTestCoverageVerifacation&#123;</span><br><span class="line">  violationRules&#123;</span><br><span class="line">    rule&#123;</span><br><span class="line">      element =<span class="string">&#x27;CLASS&#x27;</span></span><br><span class="line">      includes =[<span class="string">&#x27;com.xxx.yyyy.package&#x27;</span>] <span class="comment">//覆盖度检查package</span></span><br><span class="line">      limit&#123;</span><br><span class="line">        minimum=<span class="number">0.9</span> <span class="comment">//单元覆盖度</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.finalizedBy jacocoTestReport</span><br><span class="line">test.finalizedBy jacocoTestCoverageVerifacation  <span class="comment">//执行jacoco报告和覆盖度检查</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Spring-Test"><a href="#使用Spring-Test" class="headerlink" title="使用Spring Test"></a>使用Spring Test</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">  implementation <span class="string">&quot;org.springfamework.boot:spring-boot-starter-test&quot;</span> <span class="comment">//引入 test starter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象测试基类"><a href="#抽象测试基类" class="headerlink" title="抽象测试基类"></a>抽象测试基类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureMockMvc</span> <span class="comment">//开启Spring Mvc Controller层测试，模拟测试HTTP调用</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span> <span class="comment">//开启 test profile，方便日志输出和一些test的定制化</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes=AppApplication.class)</span> <span class="comment">//Spring Test关键注解，完成Spring Context加载和配置工作</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties=&#123;&quot;key=value&quot;&#125;)</span> <span class="comment">//测试属性配置</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes=IntegrationTestConfiguration.class,initializers=TestApplicationContextInitializer.class)</span> <span class="comment">//测试上下文配置和初始化</span></span><br><span class="line"><span class="meta">@ExtendWith(OutputCaptureExtension.class)</span> <span class="comment">//加载测试标准输入的扩展</span></span><br><span class="line"><span class="meta">@TestExecutionListeners(listeners=XXXTestExecutionListener.class,mergeMode=MergeMode.MERGE_WITH_DEFAULTS)</span> <span class="comment">//扩展测试执行Listener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIntegrationTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//@MockBean和@SpyBean的机制，会刷新Spring Context，为避免不必要的问题。@MockBean和@SpyBean集中抽象到基类，减少Spring Context的刷新</span></span><br><span class="line">  <span class="meta">@MockBean</span></span><br><span class="line">  <span class="keyword">protected</span> Service service;</span><br><span class="line">  <span class="meta">@SpyBean</span></span><br><span class="line">  <span class="keyword">protected</span> Client client;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> MockMvc mockMvc; <span class="comment">//测试Spring Mvc</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> WireMockServer WIRE_MOCK_SERVER=<span class="keyword">new</span> WireMockServer(<span class="keyword">new</span> WireMockConfiguration().dynamicPort()) <span class="comment">//Wiremock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    WIRE_MOCK_SERVER.start(); <span class="comment">//启动Wiremock</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Testcontainers"><a href="#使用Testcontainers" class="headerlink" title="使用Testcontainers"></a>使用Testcontainers</h2><p>为了方便使用Spring Boot Test和Testcontainers，直接使用的Playtika开发的Starter.</p>
<h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">  implementatin <span class="string">&quot;com.playtika.testcontaners:embedded-mysql&quot;</span></span><br><span class="line">  implementatin <span class="string">&quot;com.playtika.testcontaners:embedded-redis&quot;</span></span><br><span class="line">  implementatin <span class="string">&quot;com.playtika.testcontaners:embedded-mongodb&quot;</span></span><br><span class="line">  implementatin <span class="string">&quot;com.playtika.testcontaners:embedded-rabbitmq&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="以mysql举例"><a href="#以mysql举例" class="headerlink" title="以mysql举例"></a>以mysql举例</h4><p>bootstrap-test.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">emebdded:</span></span><br><span class="line">	<span class="attr">mysql:</span></span><br><span class="line">		<span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">		<span class="attr">init-script-path:</span> <span class="string">init_mysql.sql</span></span><br></pre></td></tr></table></figure>

<p>application-test.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">datasource:</span></span><br><span class="line">		<span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">		<span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;embbeded.mysql.host&#125;:$&#123;embbeded.mysql.port&#125;/$&#123;embbeded.mysql.schema&#125;</span></span><br><span class="line">		<span class="attr">username:</span> <span class="string">$&#123;embbeded.mysql.user&#125;</span></span><br><span class="line">		<span class="attr">password:</span> <span class="string">$&#123;embbeded.mysql.password&#125;</span></span><br></pre></td></tr></table></figure>

<p>init_msyql.sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--数据库初始化脚本，Create Table 和 Insert Sql</span></span><br></pre></td></tr></table></figure>

<h2 id="测试用例覆盖范围"><a href="#测试用例覆盖范围" class="headerlink" title="测试用例覆盖范围"></a>测试用例覆盖范围</h2><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>测试Repository与DB交互的逻辑</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>测试复杂业务逻辑</p>
<h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>测试协议转换和入参校验</p>
<h2 id="测试框架推荐"><a href="#测试框架推荐" class="headerlink" title="测试框架推荐"></a>测试框架推荐</h2><h3 id="Junit5"><a href="#Junit5" class="headerlink" title="Junit5"></a><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/">Junit5</a></h3><p>Junit5，特性和代码设计上，比Junit4好很多</p>
<h3 id="AssertJ"><a href="#AssertJ" class="headerlink" title="AssertJ"></a><a target="_blank" rel="noopener" href="https://joel-costigliola.github.io/assertj/">AssertJ</a></h3><p>断言，推荐使用AssertJ，特别是它的DSL</p>
<h3 id="Easy-Random"><a href="#Easy-Random" class="headerlink" title="Easy-Random"></a><a target="_blank" rel="noopener" href="https://github.com/j-easy/easy-random">Easy-Random</a></h3><p>很方便的创建和控制Random Object，摆脱手工New Object的麻烦</p>
<h3 id="Awaitility"><a href="#Awaitility" class="headerlink" title="Awaitility"></a><a target="_blank" rel="noopener" href="https://github.com/awaitility/awaitility">Awaitility</a></h3><p>能方便的测试异步代码</p>
<h3 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a><a target="_blank" rel="noopener" href="https://site.mockito.org/">Mockito</a></h3><p>方便Mock，Spy，Verify Bean</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhan Hao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhan Hao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
