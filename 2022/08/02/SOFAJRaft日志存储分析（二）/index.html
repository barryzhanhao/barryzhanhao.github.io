<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="LogStorage分析LogStorage 是日志存储实现，默认实现基于 RocksDB 存储，通过 LogStorage 接口扩展自定义日志存储实现。  1com.alipay.sofa.jraft.storage.LogStorage   LogStorage 日志存储实现，核心 API 接口包括： 1234567891011121314151617181920public interfac">
<meta property="og:type" content="article">
<meta property="og:title" content="SOFAJRaft日志存储分析（二）">
<meta property="og:url" content="http://example.com/2022/08/02/SOFAJRaft%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="Zhan Hao&#39;s Blogs">
<meta property="og:description" content="LogStorage分析LogStorage 是日志存储实现，默认实现基于 RocksDB 存储，通过 LogStorage 接口扩展自定义日志存储实现。  1com.alipay.sofa.jraft.storage.LogStorage   LogStorage 日志存储实现，核心 API 接口包括： 1234567891011121314151617181920public interfac">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4sn708bdaj218o0b6ad6.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4sncopqjbj21xi0sijwa.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4spclmcqdj212r0jgtaf.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4uj0jm861j20zu0jktbd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4uj73qdyej20cq0f4dgv.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4ujcwusetj21le0q2aez.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4ujhloeguj211y0cg0uy.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4uju3q33oj21d40oen28.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4uk1pj2rkj20y00cggng.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4v59lb4gij219j0u042b.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4v74kceuxj20t40xzmze.jpg">
<meta property="article:published_time" content="2022-08-02T09:08:23.000Z">
<meta property="article:modified_time" content="2022-08-05T03:37:03.177Z">
<meta property="article:author" content="Zhan Hao">
<meta property="article:tag" content="SOFAJRaft">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h4sn708bdaj218o0b6ad6.jpg">

<link rel="canonical" href="http://example.com/2022/08/02/SOFAJRaft%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>SOFAJRaft日志存储分析（二） | Zhan Hao's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zhan Hao's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/02/SOFAJRaft%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhan Hao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhan Hao's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SOFAJRaft日志存储分析（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-02 17:08:23" itemprop="dateCreated datePublished" datetime="2022-08-02T17:08:23+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-05 11:37:03" itemprop="dateModified" datetime="2022-08-05T11:37:03+08:00">2022-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">日志存储分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="LogStorage分析"><a href="#LogStorage分析" class="headerlink" title="LogStorage分析"></a>LogStorage分析</h1><p>LogStorage 是日志存储实现，默认实现基于 RocksDB 存储，通过 LogStorage 接口扩展自定义日志存储实现。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.alipay.sofa.jraft.storage.LogStorage </span><br></pre></td></tr></table></figure>

<p>LogStorage 日志存储实现，核心 API 接口包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogStorage</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>&lt;<span class="title">LogStorageOptions</span>&gt;, <span class="title">Storage</span> </span>&#123;</span><br><span class="line">		<span class="comment">//返回日志里的首/末个日志索引；</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getFirstLogIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastLogIndex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//按照日志索引获取 Log Entry 及其任期；</span></span><br><span class="line">    <span class="function">LogEntry <span class="title">getEntry</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getTerm</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//把单个/批量 Log Entry 添加到日志存储；</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">appendEntry</span><span class="params">(<span class="keyword">final</span> LogEntry entry)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">appendEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries)</span></span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//从 Log 存储头部/末尾删除日志；</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">truncatePrefix</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> firstIndexKept)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">truncateSuffix</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastIndexKept)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//删除所有现有日志，重置下任日志索引。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">reset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> nextLogIndex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中LogStorage，有五个实现，Rocks的两个实现是默认实现，其余三个是jraft-extension包提供的额外实现。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4sn708bdaj218o0b6ad6.jpg" alt="image-20220802192409955"></p>
<p>而，具体使用哪种实现，是通过SPI的方式，以BDBLogStorage为例。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4sncopqjbj21xi0sijwa.jpg" alt="image-20220802192942322"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(priority = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BDBLogStorageJRaftServiceFactory</span> <span class="keyword">extends</span> <span class="title">DefaultJRaftServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogStorage <span class="title">createLogStorage</span><span class="params">(String uri, RaftOptions raftOptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BDBLogStorage(uri, raftOptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RocksDBLogStorage"><a href="#RocksDBLogStorage" class="headerlink" title="RocksDBLogStorage"></a>RocksDBLogStorage</h1><p>RocksDBLogStorage是LogStorage的默认实现，DefaultJRaftServiceFactory返回的是RocksDBLogStorage。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJRaftServiceFactory</span> <span class="keyword">implements</span> <span class="title">JRaftServiceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogStorage <span class="title">createLogStorage</span><span class="params">(<span class="keyword">final</span> String uri, <span class="keyword">final</span> RaftOptions raftOptions)</span> </span>&#123;</span><br><span class="line">        Requires.requireTrue(StringUtils.isNotBlank(uri), <span class="string">&quot;Blank log storage uri.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RocksDBLogStorage(uri, raftOptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RocksDBLogStorage主要属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String                    path; <span class="comment">//DB存储数据路径</span></span><br><span class="line"><span class="keyword">private</span> RocksDB                         db; <span class="comment">//实际存储RocksDB</span></span><br><span class="line"><span class="keyword">private</span> ColumnFamilyHandle              defaultHandle; <span class="comment">//ColumnFamilyHandle 完成RocksDB的读写</span></span><br><span class="line"><span class="keyword">private</span> ColumnFamilyHandle              confHandle; <span class="comment">//ColumnFamily是K/V的逻辑分区</span></span><br></pre></td></tr></table></figure>

<h2 id="getEntry读取方法"><a href="#getEntry读取方法" class="headerlink" title="getEntry读取方法"></a>getEntry读取方法</h2><p>getEntry读取方法，最终是调用RocksDB的get方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LogEntry <span class="title">getEntry</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.hasLoadFirstLogIndex &amp;&amp; index &lt; <span class="keyword">this</span>.firstLogIndex) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> getEntryFromDB(index); <span class="comment">//从DB读取</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> RocksDBException | IOException e) &#123;</span><br><span class="line">          LOG.error(<span class="string">&quot;Fail to get log entry at index &#123;&#125; in data path: &#123;&#125;.&quot;</span>, index, <span class="keyword">this</span>.path, e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnlyForTest</span></span><br><span class="line">  <span class="function">LogEntry <span class="title">getEntryFromDB</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> index)</span> <span class="keyword">throws</span> IOException, RocksDBException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] keyBytes = getKeyBytes(index); <span class="comment">// Key，Value都是字节流</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] bs = onDataGet(index, getValueFromRocksDB(keyBytes));</span><br><span class="line">    <span class="keyword">if</span> (bs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> LogEntry entry = <span class="keyword">this</span>.logEntryDecoder.decode(bs);</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Bad log entry format for index=&#123;&#125;, the log data is: &#123;&#125;.&quot;</span>, index, BytesUtil.toHex(bs));</span><br><span class="line">            <span class="comment">// invalid data remove? TODO</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] getValueFromRocksDB(<span class="keyword">final</span> <span class="keyword">byte</span>[] keyBytes) <span class="keyword">throws</span> RocksDBException &#123;</span><br><span class="line">      checkState();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.db.get(<span class="keyword">this</span>.defaultHandle, keyBytes); </span><br><span class="line">      <span class="comment">//调用 org.rocksdb.RocksDB#get(org.rocksdb.ColumnFamilyHandle, byte[])</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="appendEntry写入方法"><a href="#appendEntry写入方法" class="headerlink" title="appendEntry写入方法"></a>appendEntry写入方法</h2><p>appendEntry写入方法，最终是调用RocksDB的put方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appendEntry</span><span class="params">(<span class="keyword">final</span> LogEntry entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getType() == EntryType.ENTRY_TYPE_CONFIGURATION) &#123;</span><br><span class="line">        <span class="keyword">return</span> executeBatch(batch -&gt; addConfBatch(entry, batch));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.db == <span class="keyword">null</span>) &#123;</span><br><span class="line">                LOG.warn(<span class="string">&quot;DB not initialized or destroyed in data path: &#123;&#125;.&quot;</span>, <span class="keyword">this</span>.path);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> WriteContext writeCtx = newWriteContext();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> logIndex = entry.getId().getIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] valueBytes = <span class="keyword">this</span>.logEntryEncoder.encode(entry);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] newValueBytes = onDataAppend(logIndex, valueBytes, writeCtx);</span><br><span class="line">            writeCtx.startJob();</span><br><span class="line">            <span class="keyword">this</span>.db.put(<span class="keyword">this</span>.defaultHandle, <span class="keyword">this</span>.writeOptions, getKeyBytes(logIndex), newValueBytes);</span><br><span class="line">            <span class="comment">//调用 org.rocksdb.RocksDB#put(org.rocksdb.ColumnFamilyHandle, org.rocksdb.WriteOptions, byte[], byte[])</span></span><br><span class="line">            writeCtx.joinAll();</span><br><span class="line">            <span class="keyword">if</span> (newValueBytes != valueBytes) &#123;</span><br><span class="line">                doSync();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> RocksDBException | IOException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Fail to append entry.&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RocksDB"><a href="#RocksDB" class="headerlink" title="RocksDB"></a>RocksDB</h1><p>RocksDBLogStorage底层是依托于<a target="_blank" rel="noopener" href="http://rocksdb.org/">rocksdb</a>，<a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb">github-rocksdb</a>完成存储。</p>
<blockquote>
<p>RocksDB is an <strong>embeddable</strong>  <strong>persistent</strong> <strong>key-value</strong> store for fast storage.</p>
</blockquote>
<blockquote>
<p>The RocksDB library provides a persistent key value store. <strong>Keys and values are arbitrary byte arrays</strong>. The keys are ordered within the key value store according to a user-specified comparator function.</p>
</blockquote>
<blockquote>
<p>This code is a library that forms the core building block for a fast key-value server, especially suited for storing data on flash drives. <strong>It has a Log-Structured-Merge-Database (LSM) design with flexible tradeoffs between Write-Amplification-Factor (WAF), Read-Amplification-Factor (RAF) and Space-Amplification-Factor (SAF).</strong> It has multi-threaded compactions, making it especially suitable for storing multiple terabytes of data in a single database.</p>
</blockquote>
<p>翻译一下，RocksDB 是基于 LSM-Tree 数据结构使用 C++ 编写的嵌入式 KV 存储引擎，其键值均允许使用二进制流。</p>
<p>RocksDB被广泛用于其他开源中间件。其中，Pulsar 使用 BookKeeper 作为存储层，BookKeeper 底层使用到了 RocksDB 来保存 Entry (BookKeeper 中的数据存储单元) 对应的位置索引。主流开源的 pika/kvrocks，以及云厂商的持久型 KV 存储服务，底层都是基于 RocksDB。还有大名鼎鼎的 TiDB，其存储引擎也是 RocksDB。</p>
<h1 id="LSM"><a href="#LSM" class="headerlink" title="LSM"></a>LSM</h1><h2 id="LSM定义"><a href="#LSM定义" class="headerlink" title="LSM定义"></a>LSM定义</h2><p>LSM的论文：<a target="_blank" rel="noopener" href="http://paperhub.s3.amazonaws.com/18e91eb4db2114a06ea614f0384f2784.pdf">The Log-Structured Merge-Tree (LSM Tree)</a> – O’Neil et al. ’96.</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">维基LSM定义</a>，其中，比较有意思的描述：</p>
<blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, the <strong>log-structured merge-tree</strong> (also known as <strong>LSM tree</strong>, or <strong>LSMT</strong>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-1">1]</a>) is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure">data structure</a> with performance characteristics that make it attractive for providing <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Database_index">indexed</a> access to files with high insert volume, such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transaction_log">transactional log data</a>. LSM trees, like other <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Search_tree">search trees</a>, maintain key-value pairs. LSM trees maintain data in two or more separate structures, each of which is optimized for its respective underlying storage medium; data is synchronized between the two structures efficiently, in batches.</p>
<p>One simple version of the LSM tree is a two-level LSM tree.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-2">2]</a> As described by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Patrick_O'Neil">Patrick O’Neil</a>, a two-level LSM tree comprises two <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tree_(data_structure)">tree-like</a> structures, called C0 and C1. C0 is smaller and entirely resident in memory, whereas C1 is resident on disk. New records are inserted into the memory-resident C0 component. If the insertion causes the C0 component to exceed a certain size threshold, a contiguous segment of entries is removed from C0 and merged into C1 on disk. The performance characteristics of LSM trees stem from the fact that each component is tuned to the characteristics of its underlying storage medium, and that data is efficiently migrated across media in rolling batches, using an algorithm reminiscent of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Merge_sort">merge sort</a>.</p>
<p>In order to keep down the cost of queries, the system must avoid a situation where there are too many runs.</p>
<p>LSM trees are used in data stores such as <a target="_blank" rel="noopener" href="https://asterixdb.apache.org/">Apache AsterixDB</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bigtable">Bigtable</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HBase">HBase</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/LevelDB">LevelDB</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Apache_Accumulo">Apache Accumulo</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SQLite4">SQLite4</a>,[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-6">6]</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tarantool">Tarantool</a>,[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-7">7]</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RocksDB">RocksDB</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/WiredTiger">WiredTiger</a>,[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-8">8]</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Apache_Cassandra">Apache Cassandra</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/InfluxDB">InfluxDB</a>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree#cite_note-9">9]</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scylla_(database)">ScyllaDB</a>.</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4spclmcqdj212r0jgtaf.jpg" alt="LSM_Tree"></p>
<p>LSM 树是一个复杂的算法设计，源自 Google 的 Bigtable 论文 （引入了术语 SSTable 和 memtable ）。基于 LSM 树算法设计实现的存储引擎，称之为 LSM 存储引擎。在 LevelDB、RocksDB、Cassandra、HBase 都基于 LSM 树算法实现了对应的存储引擎。</p>
<h2 id="LSM原理"><a href="#LSM原理" class="headerlink" title="LSM原理"></a>LSM原理</h2><h3 id="如何理解LSM？"><a href="#如何理解LSM？" class="headerlink" title="如何理解LSM？"></a>如何理解LSM？</h3><p>LSM解决的是高写负载的场景，通过顺序写入（sequential writes）优化数据写入。LSM tree持久化使用的是**Sorted Strings Table (SSTable)*<em>的数据结构。SSTables中key/value队，都是有序的，以key排序。其中key/value对，是以</em>segments*组织的。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4uj0jm861j20zu0jktbd.jpg" alt="output-onlinepngtools--3-"></p>
<h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>LSM 是顺序写入。当数据写入时，首先写入内存中的树结构（memtable），其底层数据结构通常是某种形式的排序树，如<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树</a>。写入时，数据将添加到此红黑树中。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4uj73qdyej20cq0f4dgv.jpg" alt="output-onlinepngtools--4-"></p>
<p>当内存中的红黑树达到预定义的大小，它将会一段segment按排序顺序刷到（flush）磁盘。通过数据结构的排序性，内存和硬盘两个层次，保证了顺序写入特性，即无论以任何顺序插入，最后刷新到硬盘都是有序的。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4ujcwusetj21le0q2aez.jpg" alt="output-onlinepngtools--5-"></p>
<h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>如何在SSTable中找到一个值呢？一种简单的方法是扫描扫描segments分段，即从最新的部分开始，然后回到最老的部分，直到找到要寻找的目标。但是这种简答的方法是低效的，另外的简单的优化是保持内存中的稀疏索引（sparse index）。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4ujhloeguj211y0cg0uy.jpg" alt="output-onlinepngtools--6-"></p>
<p>使用稀疏索引快速查找所需Key前后的值的偏移量。例如，查找key <code>dollar</code>。稀疏索引执行二进制搜索，key <code>dollar</code>介于 <code>dog</code> and <code>downgrade</code>之间。现在，只需要从偏移量17208扫描到19504，就可以找到该值（或确定该值缺失）。</p>
<p>稀疏索引，可以很好提高查询效率，但是如何查找不存在的记录呢？因为以上的算法，只是针对某个分段。为了确定不存在，仍然会在所有段文件上循环查找。这是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器bloom-filter</a>可以帮助解决问题。布隆过滤器是一种节省空间的数据结构，可以检查数据中是否存在值。在写入bloom过滤器时向其添加条目，并在读取开始时进行检查，以便有效地检查数据是否存在。</p>
<p>数据压缩</p>
<p>随着时间的推移，分段文件会积累。分段文件需要定期清理和维护，以防止分段文件数量失控。其过程称为压缩的过程。压缩是一个后台过程，不断地将旧分段组合到新分段的过程。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4uju3q33oj21d40oen28.jpg" alt="output-onlinepngtools--7-"></p>
<p>上图的示例中，segment1和segment2都有key <code>dog</code>的值。新分段segment4包含写入的最新值（84），即segment2的值转入segment4。很容易理解，根据时序性，新值覆盖原则。</p>
<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><p>分段文件被视为不可变（immutable），如何从SSTable中删除数据？删除数据实际上遵循与写入数据完全相同的逻辑。删除数据时，会写入一个Key/Value键值对，但是Value是称为墓碑（<strong>tombstone</strong>）的特殊标记。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4uk1pj2rkj20y00cggng.jpg" alt="output-onlinepngtools--8-"></p>
<p>如上图所示，key <code>dog</code>在segment1的有value52，segment2有墓碑标记的key。这表明，当查询key <code>dog</code>时，会返回不存在的响应。这意味着删除操作实际上会占用磁盘空间，最终，压缩后，<code>dog</code>键值对才不存在于磁盘上。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>数据写入存储在内存树（memtable）中。优化措施，还将更新其他数据结构（bloom过滤器和稀疏索引）。</p>
</li>
<li><p>当内存树（memtable）变得太大时，数据将按排序顺序刷新到磁盘。内存和硬盘使用相同的数据结构（SSTable）。</p>
</li>
<li><p>查询优化，当读取数据时，首先检查bloom过滤器。如果bloom过滤器指示不存在，直接返回不存在。如果bloom过滤器指示该值存在，则从分段文件中查找。</p>
</li>
<li><p>对片段文件，通过稀疏索引提高效率。</p>
</li>
<li><p>数据删除，是延迟删除，通过写入带有特殊标记的Key/Value键值对来实现，真正删除，是发生在压缩时。</p>
</li>
</ul>
<h1 id="RocksDB中的LSM"><a href="#RocksDB中的LSM" class="headerlink" title="RocksDB中的LSM"></a>RocksDB中的LSM</h1><p>首先引用下，官网的顶层设计架构图，图中的一些概念，和LSM的概念是吻合的。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4v59lb4gij219j0u042b.jpg" alt="119747261-310fb300-be47-11eb-92c3-c11719fa8a0c"></p>
<p>接下来，简单分析下读取数据Get的源码。</p>
<p>首先rocksdb封装了SuperVersion的结构体，包含当前版本号、内存中的 MemTable 和 Immutable MemTable、SST 文件信息等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// column_family.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// holds references to memtable, all immutable memtables and version</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuperVersion</span> &#123;</span></span><br><span class="line">  <span class="comment">// Accessing members of this class is not thread-safe and requires external</span></span><br><span class="line">  <span class="comment">// synchronization (ie db mutex held or on write thread).</span></span><br><span class="line">  ColumnFamilyData* cfd;</span><br><span class="line">  MemTable* mem; <span class="comment">//内存中的 MemTable</span></span><br><span class="line">  MemTableListVersion* imm; <span class="comment">//内存中的 Immutable MemTable，是集合</span></span><br><span class="line">  Version* current; <span class="comment">//SST文件，硬盘IO</span></span><br><span class="line">  MutableCFOptions mutable_cf_options;</span><br><span class="line">  <span class="comment">// Version number of the current SuperVersion</span></span><br><span class="line">  <span class="keyword">uint64_t</span> version_number; <span class="comment">//版本号</span></span><br><span class="line">  WriteStallCondition write_stall_condition;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rocksdb 的 Get 接口 DBImpl::Get 其实现主要靠 DBImpl::GetImpl 函数调用。</p>
<p>DBImpl::GetImpl</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db_impl.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::GetImpl</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; read_options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                       GetImplOptions&amp; get_impl_options)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(get_impl_options.value != <span class="literal">nullptr</span> ||</span><br><span class="line">         get_impl_options.merge_operands != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(get_impl_options.column_family);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_options.timestamp) &#123;</span><br><span class="line">    <span class="keyword">const</span> Status s = <span class="built_in">FailIfTsMismatchCf</span>(get_impl_options.column_family,</span><br><span class="line">                                        *(read_options.timestamp),</span><br><span class="line">                                        <span class="comment">/*ts_for_read=*/</span><span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Status s = <span class="built_in">FailIfCfHasTs</span>(get_impl_options.column_family);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acquire SuperVersion</span></span><br><span class="line">  SuperVersion* sv = <span class="built_in">GetAndRefSuperVersion</span>(cfd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//略</span></span><br><span class="line">  <span class="keyword">if</span> (!skip_memtable) &#123;</span><br><span class="line">    <span class="comment">// Get value associated with key</span></span><br><span class="line">    <span class="keyword">if</span> (get_impl_options.get_value) &#123;</span><br><span class="line">      <span class="comment">// ① 从内存的MemTable读取</span></span><br><span class="line">      <span class="keyword">if</span> (sv-&gt;mem-&gt;<span class="built_in">Get</span>(lkey, get_impl_options.value-&gt;<span class="built_in">GetSelf</span>(), timestamp, &amp;s,</span><br><span class="line">                       &amp;merge_context, &amp;max_covering_tombstone_seq,</span><br><span class="line">                       read_options, get_impl_options.callback,</span><br><span class="line">                       get_impl_options.is_blob_index)) &#123;</span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        get_impl_options.value-&gt;<span class="built_in">PinSelf</span>();</span><br><span class="line">        <span class="built_in">RecordTick</span>(stats_, MEMTABLE_HIT);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((s.<span class="built_in">ok</span>() || s.<span class="built_in">IsMergeInProgress</span>()) &amp;&amp;</span><br><span class="line">                 sv-&gt;imm-&gt;<span class="built_in">Get</span>(lkey, get_impl_options.value-&gt;<span class="built_in">GetSelf</span>(),</span><br><span class="line">                              timestamp, &amp;s, &amp;merge_context,</span><br><span class="line">                              &amp;max_covering_tombstone_seq, read_options,</span><br><span class="line">                              get_impl_options.callback,</span><br><span class="line">                              get_impl_options.is_blob_index)) &#123; <span class="comment">// ② 从 内存中的 Immutable MemTable读取</span></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        get_impl_options.value-&gt;<span class="built_in">PinSelf</span>();</span><br><span class="line">        <span class="built_in">RecordTick</span>(stats_, MEMTABLE_HIT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Get Merge Operands associated with key, Merge Operands should not be</span></span><br><span class="line">      <span class="comment">// merged and raw values should be returned to the user.</span></span><br><span class="line">      <span class="keyword">if</span> (sv-&gt;mem-&gt;<span class="built_in">Get</span>(lkey, <span class="comment">/*value*/</span> <span class="literal">nullptr</span>, <span class="comment">/*timestamp=*/</span><span class="literal">nullptr</span>, &amp;s,</span><br><span class="line">                       &amp;merge_context, &amp;max_covering_tombstone_seq,</span><br><span class="line">                       read_options, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">false</span>)) &#123;  <span class="comment">// ① 从内存的MemTable读取</span></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">RecordTick</span>(stats_, MEMTABLE_HIT);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((s.<span class="built_in">ok</span>() || s.<span class="built_in">IsMergeInProgress</span>()) &amp;&amp;</span><br><span class="line">                 sv-&gt;imm-&gt;<span class="built_in">GetMergeOperands</span>(lkey, &amp;s, &amp;merge_context,</span><br><span class="line">                                           &amp;max_covering_tombstone_seq,</span><br><span class="line">                                           read_options)) &#123; <span class="comment">// ② 从 内存中的 Immutable MemTable读取</span></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">RecordTick</span>(stats_, MEMTABLE_HIT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!done &amp;&amp; !s.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">IsMergeInProgress</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReturnAndCleanupSuperVersion</span>(cfd, sv);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;DBImpl::GetImpl:PostMemTableGet:0&quot;</span>);</span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;DBImpl::GetImpl:PostMemTableGet:1&quot;</span>);</span><br><span class="line">  PinnedIteratorsManager pinned_iters_mgr;</span><br><span class="line">  <span class="keyword">if</span> (!done) &#123; <span class="comment">//均没读取数据</span></span><br><span class="line">    <span class="built_in">PERF_TIMER_GUARD</span>(get_from_output_files_time);</span><br><span class="line">    <span class="comment">// ③ 从SST文件读取</span></span><br><span class="line">    sv-&gt;current-&gt;<span class="built_in">Get</span>(</span><br><span class="line">        read_options, lkey, get_impl_options.value, timestamp, &amp;s,</span><br><span class="line">        &amp;merge_context, &amp;max_covering_tombstone_seq, &amp;pinned_iters_mgr,</span><br><span class="line">        get_impl_options.get_value ? get_impl_options.value_found : <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        get_impl_options.get_value ? get_impl_options.callback : <span class="literal">nullptr</span>,</span><br><span class="line">        get_impl_options.get_value ? get_impl_options.is_blob_index : <span class="literal">nullptr</span>,</span><br><span class="line">        get_impl_options.get_value);</span><br><span class="line">    <span class="built_in">RecordTick</span>(stats_, MEMTABLE_MISS);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//略</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取顺序：MemTable -&gt; MemTableListVersion -&gt; Version</p>
<p>MemTable::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memtable.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTable::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, std::string* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string* timestamp, Status* s,</span></span></span><br><span class="line"><span class="params"><span class="function">                   MergeContext* merge_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                   SequenceNumber* max_covering_tombstone_seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                   SequenceNumber* seq, <span class="keyword">const</span> ReadOptions&amp; read_opts,</span></span></span><br><span class="line"><span class="params"><span class="function">                   ReadCallback* callback, <span class="keyword">bool</span>* is_blob_index, <span class="keyword">bool</span> do_merge)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The sequence number is updated synchronously in version_set.h</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">    <span class="comment">// Avoiding recording stats for speed.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PERF_TIMER_GUARD</span>(get_from_memtable_time);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;FragmentedRangeTombstoneIterator&gt; <span class="title">range_del_iter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      NewRangeTombstoneIterator(read_opts,</span></span></span><br><span class="line"><span class="params"><span class="function">                                GetInternalKeySeqno(key.internal_key())))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (range_del_iter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *max_covering_tombstone_seq =</span><br><span class="line">        std::<span class="built_in">max</span>(*max_covering_tombstone_seq,</span><br><span class="line">                 range_del_iter-&gt;<span class="built_in">MaxCoveringTombstoneSeqnum</span>(key.<span class="built_in">user_key</span>()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> found_final_value = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> merge_in_progress = s-&gt;<span class="built_in">IsMergeInProgress</span>();</span><br><span class="line">  <span class="keyword">bool</span> may_contain = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">size_t</span> ts_sz = <span class="built_in">GetInternalKeyComparator</span>().<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">  Slice user_key_without_ts = <span class="built_in">StripTimestampFromUserKey</span>(key.<span class="built_in">user_key</span>(), ts_sz);</span><br><span class="line">  <span class="keyword">bool</span> bloom_checked = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (bloom_filter_) &#123; <span class="comment">//布隆过滤器</span></span><br><span class="line">    <span class="comment">// when both memtable_whole_key_filtering and prefix_extractor_ are set,</span></span><br><span class="line">    <span class="comment">// only do whole key filtering for Get() to save CPU</span></span><br><span class="line">    <span class="keyword">if</span> (moptions_.memtable_whole_key_filtering) &#123;</span><br><span class="line">      may_contain = bloom_filter_-&gt;<span class="built_in">MayContain</span>(user_key_without_ts);</span><br><span class="line">      bloom_checked = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">assert</span>(prefix_extractor_);</span><br><span class="line">      <span class="keyword">if</span> (prefix_extractor_-&gt;<span class="built_in">InDomain</span>(user_key_without_ts)) &#123;</span><br><span class="line">        may_contain = bloom_filter_-&gt;<span class="built_in">MayContain</span>(</span><br><span class="line">            prefix_extractor_-&gt;<span class="built_in">Transform</span>(user_key_without_ts));</span><br><span class="line">        bloom_checked = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bloom_filter_ &amp;&amp; !may_contain) &#123;</span><br><span class="line">    <span class="comment">// iter is null if prefix bloom says the key does not exist</span></span><br><span class="line">    <span class="built_in">PERF_COUNTER_ADD</span>(bloom_memtable_miss_count, <span class="number">1</span>);</span><br><span class="line">    *seq = kMaxSequenceNumber;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bloom_checked) &#123;</span><br><span class="line">      <span class="built_in">PERF_COUNTER_ADD</span>(bloom_memtable_hit_count, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GetFromTable</span>(key, *max_covering_tombstone_seq, do_merge, callback,</span><br><span class="line">                 is_blob_index, value, timestamp, s, merge_context, seq,</span><br><span class="line">                 &amp;found_final_value, &amp;merge_in_progress); <span class="comment">//真正查找</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No change to value, since we have not yet found a Put/Delete</span></span><br><span class="line">  <span class="keyword">if</span> (!found_final_value &amp;&amp; merge_in_progress) &#123;</span><br><span class="line">    *s = Status::<span class="built_in">MergeInProgress</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PERF_COUNTER_ADD</span>(get_from_memtable_count, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> found_final_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTable::GetFromTable</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                            SequenceNumber max_covering_tombstone_seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">bool</span> do_merge, ReadCallback* callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">bool</span>* is_blob_index, std::string* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* timestamp, Status* s,</span></span></span><br><span class="line"><span class="params"><span class="function">                            MergeContext* merge_context, SequenceNumber* seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">bool</span>* found_final_value, <span class="keyword">bool</span>* merge_in_progress)</span> </span>&#123;</span><br><span class="line">  Saver saver;</span><br><span class="line">  saver.status = s;</span><br><span class="line">  saver.found_final_value = found_final_value;</span><br><span class="line">  saver.merge_in_progress = merge_in_progress;</span><br><span class="line">  saver.key = &amp;key;</span><br><span class="line">  saver.value = value;</span><br><span class="line">  saver.timestamp = timestamp;</span><br><span class="line">  saver.seq = kMaxSequenceNumber;</span><br><span class="line">  saver.mem = <span class="keyword">this</span>;</span><br><span class="line">  saver.merge_context = merge_context;</span><br><span class="line">  saver.max_covering_tombstone_seq = max_covering_tombstone_seq;</span><br><span class="line">  saver.merge_operator = moptions_.merge_operator;</span><br><span class="line">  saver.logger = moptions_.info_log;</span><br><span class="line">  saver.inplace_update_support = moptions_.inplace_update_support;</span><br><span class="line">  saver.statistics = moptions_.statistics;</span><br><span class="line">  saver.clock = clock_;</span><br><span class="line">  saver.callback_ = callback;</span><br><span class="line">  saver.is_blob_index = is_blob_index;</span><br><span class="line">  saver.do_merge = do_merge;</span><br><span class="line">  saver.allow_data_in_errors = moptions_.allow_data_in_errors;</span><br><span class="line">  table_-&gt;<span class="built_in">Get</span>(key, &amp;saver, SaveValue); <span class="comment">//查找方法</span></span><br><span class="line">  *seq = saver.seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTableRep::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; k, <span class="keyword">void</span>* callback_args,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">bool</span> (*callback_func)(<span class="keyword">void</span>* arg, <span class="keyword">const</span> <span class="keyword">char</span>* entry))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> iter = <span class="built_in">GetDynamicPrefixIterator</span>(); <span class="comment">//使用skiplist跳表查找</span></span><br><span class="line">  <span class="keyword">for</span> (iter-&gt;<span class="built_in">Seek</span>(k.<span class="built_in">internal_key</span>(), k.<span class="built_in">memtable_key</span>().<span class="built_in">data</span>());</span><br><span class="line">       iter-&gt;<span class="built_in">Valid</span>() &amp;&amp; <span class="built_in">callback_func</span>(callback_args, iter-&gt;<span class="built_in">key</span>());</span><br><span class="line">       iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// skiplistrep.cc </span></span><br><span class="line">  <span class="function">MemTableRep::Iterator* <span class="title">GetIterator</span><span class="params">(Arena* arena = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lookahead_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">void</span> *mem =</span><br><span class="line">        arena ? arena-&gt;<span class="built_in">AllocateAligned</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SkipListRep::LookaheadIterator))</span><br><span class="line">              : <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SkipListRep::LookaheadIterator));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">new</span></span> (mem) SkipListRep::<span class="built_in">LookaheadIterator</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *mem =</span><br><span class="line">        arena ? arena-&gt;<span class="built_in">AllocateAligned</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SkipListRep::Iterator))</span><br><span class="line">              : <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(SkipListRep::Iterator));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in"><span class="keyword">new</span></span> (mem) SkipListRep::<span class="built_in">Iterator</span>(&amp;skip_list_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>MemTableListVersion::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memtable_list.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Search all the memtables starting from the most recent one.</span></span><br><span class="line"><span class="comment">// Return the most recent value found, if any.</span></span><br><span class="line"><span class="comment">// Operands stores the list of merge operations to apply, so far.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTableListVersion::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, std::string* value,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::string* timestamp, Status* s,</span></span></span><br><span class="line"><span class="params"><span class="function">                              MergeContext* merge_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                              SequenceNumber* max_covering_tombstone_seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                              SequenceNumber* seq, <span class="keyword">const</span> ReadOptions&amp; read_opts,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ReadCallback* callback, <span class="keyword">bool</span>* is_blob_index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetFromList</span>(&amp;memlist_, key, value, timestamp, s, merge_context,</span><br><span class="line">                     max_covering_tombstone_seq, seq, read_opts, callback,</span><br><span class="line">                     is_blob_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTableListVersion::GetFromList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::list&lt;MemTable*&gt;* list, <span class="keyword">const</span> LookupKey&amp; key, std::string* value,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::string* timestamp, Status* s, MergeContext* merge_context,</span></span></span><br><span class="line"><span class="params"><span class="function">    SequenceNumber* max_covering_tombstone_seq, SequenceNumber* seq,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> ReadOptions&amp; read_opts, ReadCallback* callback, <span class="keyword">bool</span>* is_blob_index)</span> </span>&#123;</span><br><span class="line">  *seq = kMaxSequenceNumber;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; memtable : *list) &#123;</span><br><span class="line">    SequenceNumber current_seq = kMaxSequenceNumber;</span><br><span class="line">    <span class="comment">//调用memtable的Get方法</span></span><br><span class="line">    <span class="keyword">bool</span> done = memtable-&gt;<span class="built_in">Get</span>(key, value, timestamp, s, merge_context,</span><br><span class="line">                              max_covering_tombstone_seq, &amp;current_seq,</span><br><span class="line">                              read_opts, callback, is_blob_index);</span><br><span class="line">    <span class="keyword">if</span> (*seq == kMaxSequenceNumber) &#123;</span><br><span class="line">      <span class="comment">// Store the most recent sequence number of any operation on this key.</span></span><br><span class="line">      <span class="comment">// Since we only care about the most recent change, we only need to</span></span><br><span class="line">      <span class="comment">// return the first operation found when searching memtables in</span></span><br><span class="line">      <span class="comment">// reverse-chronological order.</span></span><br><span class="line">      <span class="comment">// current_seq would be equal to kMaxSequenceNumber if the value was to be</span></span><br><span class="line">      <span class="comment">// skipped. This allows seq to be assigned again when the next value is</span></span><br><span class="line">      <span class="comment">// read.</span></span><br><span class="line">      *seq = current_seq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(*seq != kMaxSequenceNumber || s-&gt;<span class="built_in">IsNotFound</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!done &amp;&amp; !s-&gt;<span class="built_in">ok</span>() &amp;&amp; !s-&gt;<span class="built_in">IsMergeInProgress</span>() &amp;&amp; !s-&gt;<span class="built_in">IsNotFound</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MemTableListVersion 用链表的形式保存了所有 Immutable memtable 的结构，查找时，按时间序依次查找于每一个 memtable，如果任何一个 memtable 查找到结果则立即返回，即返回最新的返回值。具体 memtable 查找见上述 MemTable::Get 接口。</p>
<p>Version::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version_set.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; read_options, <span class="keyword">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="params"><span class="function">                  PinnableSlice* value, std::string* timestamp, Status* status,</span></span></span><br><span class="line"><span class="params"><span class="function">                  MergeContext* merge_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                  SequenceNumber* max_covering_tombstone_seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                  PinnedIteratorsManager* pinned_iters_mgr, <span class="keyword">bool</span>* value_found,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">bool</span>* key_exists, SequenceNumber* seq, ReadCallback* callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">bool</span>* is_blob, <span class="keyword">bool</span> do_merge)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//fd文件描述符</span></span><br><span class="line">  <span class="function">FilePicker <span class="title">fp</span><span class="params">(user_key, ikey, &amp;storage_info_.level_files_brief_,</span></span></span><br><span class="line"><span class="params"><span class="function">                storage_info_.num_non_empty_levels_,</span></span></span><br><span class="line"><span class="params"><span class="function">                &amp;storage_info_.file_indexer_, user_comparator(),</span></span></span><br><span class="line"><span class="params"><span class="function">                internal_comparator())</span></span>;</span><br><span class="line">  FdWithKeyRange* f = fp.<span class="built_in">GetNextFile</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (f != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="comment">//略</span></span><br><span class="line">    *status = table_cache_-&gt;<span class="built_in">Get</span>(</span><br><span class="line">        read_options, *<span class="built_in">internal_comparator</span>(), *f-&gt;file_metadata, ikey,</span><br><span class="line">        &amp;get_context, mutable_cf_options_.prefix_extractor,</span><br><span class="line">        cfd_-&gt;<span class="built_in">internal_stats</span>()-&gt;<span class="built_in">GetFileReadHist</span>(fp.<span class="built_in">GetHitFileLevel</span>()),</span><br><span class="line">        <span class="built_in">IsFilterSkipped</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(fp.<span class="built_in">GetHitFileLevel</span>()),</span><br><span class="line">                        fp.<span class="built_in">IsHitFileLastInLevel</span>()),</span><br><span class="line">        fp.<span class="built_in">GetHitFileLevel</span>(), max_file_size_for_l0_meta_pin_);</span><br><span class="line">	<span class="comment">//略</span></span><br><span class="line">  f = fp.<span class="built_in">GetNextFile</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetNextFile 函数会遍历所有的 level，然后再遍历每个 level 的所有的文件，这里会对 level 0 的文件做一个特殊处理，这是因为只有 level 0 的 SST 的 range 不是有序的，因此我们每次查找需要查找所有的文件，也就是会一个个的遍历；而在非 level 0，我们只需要按照二分查找来得到对应的文件即可，如果二分查找不存在，那么我就需要进入下一个 level 进行查找。</p>
<p>调用 TableCache::Get 遍历单个 SST 文件，如果查找到结果立即返回。</p>
<p>TableCache::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table_cache.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> InternalKeyComparator&amp; internal_comparator,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> FileMetaData&amp; file_meta, <span class="keyword">const</span> Slice&amp; k, GetContext* get_context,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">const</span> SliceTransform&gt;&amp; prefix_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">    HistogramImpl* file_read_hist, <span class="keyword">bool</span> skip_filters, <span class="keyword">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">size_t</span> max_file_size_for_l0_meta_pin)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; fd = file_meta.fd;</span><br><span class="line">  std::string* row_cache_entry = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ROCKSDB_LITE</span></span><br><span class="line">  IterKey row_cache_key;</span><br><span class="line">  std::string row_cache_entry_buffer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check row cache if enabled. Since row cache does not currently store</span></span><br><span class="line">  <span class="comment">// sequence numbers, we cannot use it if we need to fetch the sequence.</span></span><br><span class="line">  <span class="keyword">if</span> (ioptions_.row_cache &amp;&amp; !get_context-&gt;<span class="built_in">NeedToReadSequence</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> user_key = <span class="built_in">ExtractUserKey</span>(k);</span><br><span class="line">    <span class="built_in">CreateRowCacheKeyPrefix</span>(options, fd, k, get_context, row_cache_key);</span><br><span class="line">    done = <span class="built_in">GetFromRowCache</span>(user_key, row_cache_key, row_cache_key.<span class="built_in">Size</span>(),</span><br><span class="line">                           get_context);</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">      row_cache_entry = &amp;row_cache_entry_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// ROCKSDB_LITE</span></span></span><br><span class="line">  Status s;</span><br><span class="line">  TableReader* t = fd.table_reader;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(s.<span class="built_in">ok</span>());</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">//先从缓存中读取</span></span><br><span class="line">      s = <span class="built_in">FindTable</span>(options, file_options_, internal_comparator, fd, &amp;handle,</span><br><span class="line">                    prefix_extractor,</span><br><span class="line">                    options.read_tier == kBlockCacheTier <span class="comment">/* no_io */</span>,</span><br><span class="line">                    <span class="literal">true</span> <span class="comment">/* record_read_stats */</span>, file_read_hist, skip_filters,</span><br><span class="line">                    level, <span class="literal">true</span> <span class="comment">/* prefetch_index_and_filter_in_cache */</span>,</span><br><span class="line">                    max_file_size_for_l0_meta_pin, file_meta.temperature);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        t = <span class="built_in">GetTableReaderFromHandle</span>(handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SequenceNumber* max_covering_tombstone_seq =</span><br><span class="line">        get_context-&gt;<span class="built_in">max_covering_tombstone_seq</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; max_covering_tombstone_seq != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        !options.ignore_range_deletions) &#123;</span><br><span class="line">      <span class="function">std::unique_ptr&lt;FragmentedRangeTombstoneIterator&gt; <span class="title">range_del_iter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          t-&gt;NewRangeTombstoneIterator(options))</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (range_del_iter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *max_covering_tombstone_seq = std::<span class="built_in">max</span>(</span><br><span class="line">            *max_covering_tombstone_seq,</span><br><span class="line">            range_del_iter-&gt;<span class="built_in">MaxCoveringTombstoneSeqnum</span>(<span class="built_in">ExtractUserKey</span>(k)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      get_context-&gt;<span class="built_in">SetReplayLog</span>(row_cache_entry);  <span class="comment">// nullptr if no cache.</span></span><br><span class="line">      s = t-&gt;<span class="built_in">Get</span>(options, k, get_context, prefix_extractor.<span class="built_in">get</span>(), skip_filters); <span class="comment">//从BlockBasedTable读取，即单个sst文件</span></span><br><span class="line">      get_context-&gt;<span class="built_in">SetReplayLog</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.read_tier == kBlockCacheTier &amp;&amp; s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">      <span class="comment">// Couldn&#x27;t find Table in cache but treat as kFound if no_io set</span></span><br><span class="line">      get_context-&gt;<span class="built_in">MarkKeyMayExist</span>();</span><br><span class="line">      s = Status::<span class="built_in">OK</span>();</span><br><span class="line">      done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ROCKSDB_LITE</span></span><br><span class="line">  <span class="comment">// Put the replay log in row cache only if something was found.</span></span><br><span class="line">  <span class="keyword">if</span> (!done &amp;&amp; s.<span class="built_in">ok</span>() &amp;&amp; row_cache_entry &amp;&amp; !row_cache_entry-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> charge = row_cache_entry-&gt;<span class="built_in">capacity</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(std::string);</span><br><span class="line">    <span class="keyword">void</span>* row_ptr = <span class="keyword">new</span> std::<span class="built_in">string</span>(std::<span class="built_in">move</span>(*row_cache_entry));</span><br><span class="line">    <span class="comment">// If row cache is full, it&#x27;s OK to continue.</span></span><br><span class="line">    ioptions_.row_cache</span><br><span class="line">        -&gt;<span class="built_in">Insert</span>(row_cache_key.<span class="built_in">GetUserKey</span>(), row_ptr, charge,</span><br><span class="line">                 &amp;DeleteEntry&lt;std::string&gt;)</span><br><span class="line">        .<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// ROCKSDB_LITE</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">ReleaseHandle</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> ReadOptions&amp; ro, <span class="keyword">const</span> FileOptions&amp; file_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> InternalKeyComparator&amp; internal_comparator, <span class="keyword">const</span> FileDescriptor&amp; fd,</span></span></span><br><span class="line"><span class="params"><span class="function">    Cache::Handle** handle,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">const</span> SliceTransform&gt;&amp; prefix_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">bool</span> no_io, <span class="keyword">bool</span> record_read_stats, HistogramImpl* file_read_hist,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> skip_filters, <span class="keyword">int</span> level, <span class="keyword">bool</span> prefetch_index_and_filter_in_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">size_t</span> max_file_size_for_l0_meta_pin, Temperature file_temperature)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PERF_TIMER_GUARD_WITH_CLOCK</span>(find_table_nanos, ioptions_.clock);</span><br><span class="line">  <span class="keyword">uint64_t</span> number = fd.<span class="built_in">GetNumber</span>();</span><br><span class="line">  Slice key = <span class="built_in">GetSliceForFileNumber</span>(&amp;number);</span><br><span class="line">  *handle = cache_-&gt;<span class="built_in">Lookup</span>(key); <span class="comment">//从缓存中读取</span></span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(<span class="string">&quot;TableCache::FindTable:0&quot;</span>,</span><br><span class="line">                           <span class="keyword">const_cast</span>&lt;<span class="keyword">bool</span>*&gt;(&amp;no_io));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (no_io) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">Incomplete</span>(<span class="string">&quot;Table not found in table_cache, no_io is set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MutexLock <span class="title">load_lock</span><span class="params">(loader_mutex_.get(key))</span></span>;</span><br><span class="line">    <span class="comment">// We check the cache again under loading mutex</span></span><br><span class="line">    *handle = cache_-&gt;<span class="built_in">Lookup</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (*handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;TableReader&gt; table_reader;</span><br><span class="line">    <span class="comment">//真实读取，从磁盘读取</span></span><br><span class="line">    Status s = <span class="built_in">GetTableReader</span>(</span><br><span class="line">        ro, file_options, internal_comparator, fd, <span class="literal">false</span> <span class="comment">/* sequential mode */</span>,</span><br><span class="line">        record_read_stats, file_read_hist, &amp;table_reader, prefix_extractor,</span><br><span class="line">        skip_filters, level, prefetch_index_and_filter_in_cache,</span><br><span class="line">        max_file_size_for_l0_meta_pin, file_temperature);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(table_reader == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="built_in">RecordTick</span>(ioptions_.stats, NO_FILE_ERRORS);</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//插入缓存</span></span><br><span class="line">      s = cache_-&gt;<span class="built_in">Insert</span>(key, table_reader.<span class="built_in">get</span>(), <span class="number">1</span>, &amp;DeleteEntry&lt;TableReader&gt;,</span><br><span class="line">                         handle);</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// Release ownership of table reader.</span></span><br><span class="line">        table_reader.<span class="built_in">release</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockBasedTable::Get</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block_based_table_reader.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BlockBasedTable::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; read_options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                            GetContext* get_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> SliceTransform* prefix_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">bool</span> skip_filters)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> may_match = <span class="built_in">FullFilterKeyMayMatch</span>(</span><br><span class="line">      filter, key, no_io, prefix_extractor, get_context, &amp;lookup_context,</span><br><span class="line">      read_options.rate_limiter_priority); <span class="comment">//数据块Index，稀疏索引查找</span></span><br><span class="line">  <span class="built_in">TEST_SYNC_POINT</span>(<span class="string">&quot;BlockBasedTable::Get:AfterFilterMatch&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!may_match) &#123;</span><br><span class="line">    <span class="built_in">RecordTick</span>(rep_-&gt;ioptions.stats, BLOOM_FILTER_USEFUL);</span><br><span class="line">    <span class="built_in">PERF_COUNTER_BY_LEVEL_ADD</span>(bloom_filter_useful, <span class="number">1</span>, rep_-&gt;level); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//命中</span></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">		<span class="comment">//遍历，循环查找</span></span><br><span class="line">    <span class="keyword">for</span> (iiter-&gt;<span class="built_in">Seek</span>(key); iiter-&gt;<span class="built_in">Valid</span>() &amp;&amp; !done; iiter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">      IndexValue v = iiter-&gt;<span class="built_in">value</span>();</span><br><span class="line">			<span class="comment">//略</span></span><br><span class="line">      NewDataBlockIterator&lt;DataBlockIter&gt;(</span><br><span class="line">          read_options, v.handle, &amp;biter, BlockType::kData, get_context,</span><br><span class="line">          &amp;lookup_data_block_context, <span class="comment">/*prefetch_buffer=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">          <span class="comment">/*for_compaction=*/</span><span class="literal">false</span>, <span class="comment">/*async_read=*/</span><span class="literal">false</span>, tmp_status);</span><br><span class="line">			<span class="comment">//no_io，命中内存</span></span><br><span class="line">      <span class="keyword">if</span> (no_io &amp;&amp; biter.<span class="built_in">status</span>().<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">        <span class="comment">// couldn&#x27;t get block from block_cache</span></span><br><span class="line">        <span class="comment">// Update Saver.state to Found because we are only looking for</span></span><br><span class="line">        <span class="comment">// whether we can guarantee the key is not there when &quot;no_io&quot; is set</span></span><br><span class="line">        get_context-&gt;<span class="built_in">MarkKeyMayExist</span>();</span><br><span class="line">        s = biter.<span class="built_in">status</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!biter.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        s = biter.<span class="built_in">status</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">bool</span> may_exist = biter.<span class="built_in">SeekForGet</span>(key);</span><br><span class="line">      <span class="comment">// If user-specified timestamp is supported, we cannot end the search</span></span><br><span class="line">      <span class="comment">// just because hash index lookup indicates the key+ts does not exist.</span></span><br><span class="line">      <span class="keyword">if</span> (!may_exist &amp;&amp; ts_sz == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// HashSeek cannot find the key this block and the the iter is not</span></span><br><span class="line">        <span class="comment">// the end of the block, i.e. cannot be in the following blocks</span></span><br><span class="line">        <span class="comment">// either. In this case, the seek_key cannot be found, so we break</span></span><br><span class="line">        <span class="comment">// from the top level for-loop.</span></span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Call the *saver function on each entry/block until it returns false</span></span><br><span class="line">        <span class="keyword">for</span> (; biter.<span class="built_in">Valid</span>(); biter.<span class="built_in">Next</span>()) &#123;</span><br><span class="line">          ParsedInternalKey parsed_key;</span><br><span class="line">          Status pik_status = <span class="built_in">ParseInternalKey</span>(</span><br><span class="line">              biter.<span class="built_in">key</span>(), &amp;parsed_key, <span class="literal">false</span> <span class="comment">/* log_err_key */</span>);  <span class="comment">// TODO</span></span><br><span class="line">          <span class="keyword">if</span> (!pik_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            s = pik_status;</span><br><span class="line">          &#125;</span><br><span class="line">					<span class="comment">//从硬盘的SST文件读取</span></span><br><span class="line">          <span class="keyword">if</span> (!get_context-&gt;<span class="built_in">SaveValue</span>(</span><br><span class="line">                  parsed_key, biter.<span class="built_in">value</span>(), &amp;matched,</span><br><span class="line">                  biter.<span class="built_in">IsValuePinned</span>() ? &amp;biter : <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (get_context-&gt;<span class="built_in">State</span>() == GetContext::GetState::kFound) &#123;</span><br><span class="line">              does_referenced_key_exist = <span class="literal">true</span>;</span><br><span class="line">              referenced_data_size = biter.<span class="built_in">key</span>().<span class="built_in">size</span>() + biter.<span class="built_in">value</span>().<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = biter.<span class="built_in">status</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockBasedTable是 RocksDB中默认的 SST table的格式。 </p>
<h3 id="File-format"><a href="#File-format" class="headerlink" title="File format"></a>File format</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1: filter block]                  (see section: &quot;filter&quot; Meta Block)</span><br><span class="line">[meta block 2: index block]</span><br><span class="line">[meta block 3: compression dictionary block]  (see section: &quot;compression dictionary&quot; Meta Block)</span><br><span class="line">[meta block 4: range deletion block]          (see section: &quot;range deletion&quot; Meta Block)</span><br><span class="line">[meta block 5: stats block]                   (see section: &quot;properties&quot; Meta Block)</span><br><span class="line">...</span><br><span class="line">[meta block K: future extended block]  (we may add more meta blocks in the future)</span><br><span class="line">[metaindex block]</span><br><span class="line">[Footer]                               (fixed size; starts at file_size - sizeof(Footer))</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>Rocksdb 的Get 读取数据会不可避免的带来读放大（Read Amplification)。Rocksdb 的读操作需要从新到旧（从上到下）一层一层查找，直到找到想要的数据。这个过程可能需要不止一次 I/O。从level0 开始，潜在的可能会造成I/O，对于level1及以下的层级，最差情况每一层都定位到一个sst 文件，进行一次潜在I/O。这样会造成大量的读放大。所幸，引进了bloom filter减少了可能的读盘次数。另外，引入缓存优化措施，Rocksdb在各个阶段，实现了不同的缓存。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4v74kceuxj20t40xzmze.jpg" alt="rocksdb_get"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.sofastack.tech/blog/sofa-jraft-algorithm-storage-module-deep-dive/">https://www.sofastack.tech/blog/sofa-jraft-algorithm-storage-module-deep-dive/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/426053729">https://zhuanlan.zhihu.com/p/426053729</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/">https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">https://en.wikipedia.org/wiki/Log-structured_merge-tree</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/">https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/</a></p>
<p><a target="_blank" rel="noopener" href="https://yetanotherdevblog.com/lsm/">https://yetanotherdevblog.com/lsm/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.iggiewang.cn/2021/01/17/Rocksdb-Get/">https://www.iggiewang.cn/2021/01/17/Rocksdb-Get/</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SOFAJRaft/" rel="tag"># SOFAJRaft</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/28/SOFAJRaft%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90(%E4%B8%80)/" rel="prev" title="SOFAJRaft日志存储分析（一）">
      <i class="fa fa-chevron-left"></i> SOFAJRaft日志存储分析（一）
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LogStorage%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">LogStorage分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RocksDBLogStorage"><span class="nav-number">2.</span> <span class="nav-text">RocksDBLogStorage</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#getEntry%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">getEntry读取方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#appendEntry%E5%86%99%E5%85%A5%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">appendEntry写入方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RocksDB"><span class="nav-number">3.</span> <span class="nav-text">RocksDB</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LSM"><span class="nav-number">4.</span> <span class="nav-text">LSM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LSM%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">LSM定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LSM%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">LSM原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3LSM%EF%BC%9F"><span class="nav-number">4.2.1.</span> <span class="nav-text">如何理解LSM？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5"><span class="nav-number">4.2.2.</span> <span class="nav-text">数据写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="nav-number">4.2.3.</span> <span class="nav-text">数据读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4"><span class="nav-number">4.2.4.</span> <span class="nav-text">数据删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.2.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RocksDB%E4%B8%AD%E7%9A%84LSM"><span class="nav-number">5.</span> <span class="nav-text">RocksDB中的LSM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#File-format"><span class="nav-number">5.0.1.</span> <span class="nav-text">File format</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhan Hao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhan Hao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
